<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Scripts\lib\PreloadJS\lib\preloadjs-NEXT.combined.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ButtonHelper.html">ButtonHelper</a></li>
                                <li><a href="../classes/DisplayProps.html">DisplayProps</a></li>
                                <li><a href="../classes/Event.html">Event</a></li>
                                <li><a href="../classes/EventDispatcher.html">EventDispatcher</a></li>
                                <li><a href="../classes/Graphics.html">Graphics</a></li>
                                <li><a href="../classes/Graphics.AbstractLoader.html">Graphics.AbstractLoader</a></li>
                                <li><a href="../classes/Graphics.AbstractMediaLoader.html">Graphics.AbstractMediaLoader</a></li>
                                <li><a href="../classes/Graphics.AbstractPlugin.html">Graphics.AbstractPlugin</a></li>
                                <li><a href="../classes/Graphics.AbstractRequest.html">Graphics.AbstractRequest</a></li>
                                <li><a href="../classes/Graphics.AbstractSoundInstance.html">Graphics.AbstractSoundInstance</a></li>
                                <li><a href="../classes/Graphics.AlphaMapFilter.html">Graphics.AlphaMapFilter</a></li>
                                <li><a href="../classes/Graphics.AlphaMaskFilter.html">Graphics.AlphaMaskFilter</a></li>
                                <li><a href="../classes/Graphics.Arc.html">Graphics.Arc</a></li>
                                <li><a href="../classes/Graphics.ArcTo.html">Graphics.ArcTo</a></li>
                                <li><a href="../classes/Graphics.AudioSprite.html">Graphics.AudioSprite</a></li>
                                <li><a href="../classes/Graphics.BeginPath.html">Graphics.BeginPath</a></li>
                                <li><a href="../classes/Graphics.BezierCurveTo.html">Graphics.BezierCurveTo</a></li>
                                <li><a href="../classes/Graphics.BinaryLoader.html">Graphics.BinaryLoader</a></li>
                                <li><a href="../classes/Graphics.Bitmap.html">Graphics.Bitmap</a></li>
                                <li><a href="../classes/Graphics.BitmapText.html">Graphics.BitmapText</a></li>
                                <li><a href="../classes/Graphics.BlurFilter.html">Graphics.BlurFilter</a></li>
                                <li><a href="../classes/Graphics.Circle.html">Graphics.Circle</a></li>
                                <li><a href="../classes/Graphics.ClosePath.html">Graphics.ClosePath</a></li>
                                <li><a href="../classes/Graphics.ColorFilter.html">Graphics.ColorFilter</a></li>
                                <li><a href="../classes/Graphics.ColorMatrix.html">Graphics.ColorMatrix</a></li>
                                <li><a href="../classes/Graphics.ColorMatrixFilter.html">Graphics.ColorMatrixFilter</a></li>
                                <li><a href="../classes/Graphics.Container.html">Graphics.Container</a></li>
                                <li><a href="../classes/Graphics.CordovaAudioLoader.html">Graphics.CordovaAudioLoader</a></li>
                                <li><a href="../classes/Graphics.CordovaAudioPlugin.html">Graphics.CordovaAudioPlugin</a></li>
                                <li><a href="../classes/Graphics.CordovaAudioSoundInstance.html">Graphics.CordovaAudioSoundInstance</a></li>
                                <li><a href="../classes/Graphics.CSSLoader.html">Graphics.CSSLoader</a></li>
                                <li><a href="../classes/Graphics.DataUtils.html">Graphics.DataUtils</a></li>
                                <li><a href="../classes/Graphics.DisplayObject.html">Graphics.DisplayObject</a></li>
                                <li><a href="../classes/Graphics.DOMElement.html">Graphics.DOMElement</a></li>
                                <li><a href="../classes/Graphics.DomUtils.html">Graphics.DomUtils</a></li>
                                <li><a href="../classes/Graphics.Ease.html">Graphics.Ease</a></li>
                                <li><a href="../classes/Graphics.EaselJS.html">Graphics.EaselJS</a></li>
                                <li><a href="../classes/Graphics.Ellipse.html">Graphics.Ellipse</a></li>
                                <li><a href="../classes/Graphics.ErrorEvent.html">Graphics.ErrorEvent</a></li>
                                <li><a href="../classes/Graphics.Fill.html">Graphics.Fill</a></li>
                                <li><a href="../classes/Graphics.Filter.html">Graphics.Filter</a></li>
                                <li><a href="../classes/Graphics.FlashAudioLoader.html">Graphics.FlashAudioLoader</a></li>
                                <li><a href="../classes/Graphics.FlashAudioPlugin.html">Graphics.FlashAudioPlugin</a></li>
                                <li><a href="../classes/Graphics.FlashAudioSoundInstance.html">Graphics.FlashAudioSoundInstance</a></li>
                                <li><a href="../classes/Graphics.HTMLAudioPlugin.html">Graphics.HTMLAudioPlugin</a></li>
                                <li><a href="../classes/Graphics.HTMLAudioSoundInstance.html">Graphics.HTMLAudioSoundInstance</a></li>
                                <li><a href="../classes/Graphics.HTMLAudioTagPool.html">Graphics.HTMLAudioTagPool</a></li>
                                <li><a href="../classes/Graphics.ImageLoader.html">Graphics.ImageLoader</a></li>
                                <li><a href="../classes/Graphics.JavaScriptLoader.html">Graphics.JavaScriptLoader</a></li>
                                <li><a href="../classes/Graphics.JSONLoader.html">Graphics.JSONLoader</a></li>
                                <li><a href="../classes/Graphics.JSONPLoader.html">Graphics.JSONPLoader</a></li>
                                <li><a href="../classes/Graphics.LineTo.html">Graphics.LineTo</a></li>
                                <li><a href="../classes/Graphics.LoadItem.html">Graphics.LoadItem</a></li>
                                <li><a href="../classes/Graphics.LoadQueue.html">Graphics.LoadQueue</a></li>
                                <li><a href="../classes/Graphics.ManifestLoader.html">Graphics.ManifestLoader</a></li>
                                <li><a href="../classes/Graphics.MediaTagRequest.html">Graphics.MediaTagRequest</a></li>
                                <li><a href="../classes/Graphics.MotionGuidePlugin.html">Graphics.MotionGuidePlugin</a></li>
                                <li><a href="../classes/Graphics.MoveTo.html">Graphics.MoveTo</a></li>
                                <li><a href="../classes/Graphics.MovieClip.html">Graphics.MovieClip</a></li>
                                <li><a href="../classes/Graphics.MovieClipPlugin.html">Graphics.MovieClipPlugin</a></li>
                                <li><a href="../classes/Graphics.PlayPropsConfig.html">Graphics.PlayPropsConfig</a></li>
                                <li><a href="../classes/Graphics.PolyStar.html">Graphics.PolyStar</a></li>
                                <li><a href="../classes/Graphics.PreloadJS.html">Graphics.PreloadJS</a></li>
                                <li><a href="../classes/Graphics.ProgressEvent.html">Graphics.ProgressEvent</a></li>
                                <li><a href="../classes/Graphics.QuadraticCurveTo.html">Graphics.QuadraticCurveTo</a></li>
                                <li><a href="../classes/Graphics.Rect.html">Graphics.Rect</a></li>
                                <li><a href="../classes/Graphics.RequestUtils.html">Graphics.RequestUtils</a></li>
                                <li><a href="../classes/Graphics.RoundRect.html">Graphics.RoundRect</a></li>
                                <li><a href="../classes/Graphics.Shape.html">Graphics.Shape</a></li>
                                <li><a href="../classes/Graphics.Sound.html">Graphics.Sound</a></li>
                                <li><a href="../classes/Graphics.SoundJS.html">Graphics.SoundJS</a></li>
                                <li><a href="../classes/Graphics.SoundLoader.html">Graphics.SoundLoader</a></li>
                                <li><a href="../classes/Graphics.Sprite.html">Graphics.Sprite</a></li>
                                <li><a href="../classes/Graphics.SpriteContainer.html">Graphics.SpriteContainer</a></li>
                                <li><a href="../classes/Graphics.SpriteSheetBuilder.html">Graphics.SpriteSheetBuilder</a></li>
                                <li><a href="../classes/Graphics.SpriteSheetLoader.html">Graphics.SpriteSheetLoader</a></li>
                                <li><a href="../classes/Graphics.SpriteSheetUtils.html">Graphics.SpriteSheetUtils</a></li>
                                <li><a href="../classes/Graphics.SpriteStage.html">Graphics.SpriteStage</a></li>
                                <li><a href="../classes/Graphics.Stage.html">Graphics.Stage</a></li>
                                <li><a href="../classes/Graphics.Stroke.html">Graphics.Stroke</a></li>
                                <li><a href="../classes/Graphics.StrokeDash.html">Graphics.StrokeDash</a></li>
                                <li><a href="../classes/Graphics.StrokeStyle.html">Graphics.StrokeStyle</a></li>
                                <li><a href="../classes/Graphics.SVGLoader.html">Graphics.SVGLoader</a></li>
                                <li><a href="../classes/Graphics.TagRequest.html">Graphics.TagRequest</a></li>
                                <li><a href="../classes/Graphics.Text.html">Graphics.Text</a></li>
                                <li><a href="../classes/Graphics.TextLoader.html">Graphics.TextLoader</a></li>
                                <li><a href="../classes/Graphics.Timeline.html">Graphics.Timeline</a></li>
                                <li><a href="../classes/Graphics.Touch.html">Graphics.Touch</a></li>
                                <li><a href="../classes/Graphics.Tween.html">Graphics.Tween</a></li>
                                <li><a href="../classes/Graphics.TweenJS.html">Graphics.TweenJS</a></li>
                                <li><a href="../classes/Graphics.VideoLoader.html">Graphics.VideoLoader</a></li>
                                <li><a href="../classes/Graphics.WebAudioLoader.html">Graphics.WebAudioLoader</a></li>
                                <li><a href="../classes/Graphics.WebAudioPlugin.html">Graphics.WebAudioPlugin</a></li>
                                <li><a href="../classes/Graphics.WebAudioSoundInstance.html">Graphics.WebAudioSoundInstance</a></li>
                                <li><a href="../classes/Graphics.XHRRequest.html">Graphics.XHRRequest</a></li>
                                <li><a href="../classes/Graphics.XMLLoader.html">Graphics.XMLLoader</a></li>
                                <li><a href="../classes/Matrix2D.html">Matrix2D</a></li>
                                <li><a href="../classes/MouseEvent.html">MouseEvent</a></li>
                                <li><a href="../classes/Point.html">Point</a></li>
                                <li><a href="../classes/Rectangle.html">Rectangle</a></li>
                                <li><a href="../classes/Shadow.html">Shadow</a></li>
                                <li><a href="../classes/SpriteSheet.html">SpriteSheet</a></li>
                                <li><a href="../classes/Ticker.html">Ticker</a></li>
                                <li><a href="../classes/UID.html">UID</a></li>
                                <li><a href="../classes/Utility Methods.html">Utility Methods</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: Scripts\lib\PreloadJS\lib\preloadjs-NEXT.combined.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
* PreloadJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the &quot;Software&quot;), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	/**
	 * Static class holding library specific information such as the version and buildDate of the library.
	 * @class PreloadJS
	 **/
	var s = createjs.PreloadJS = createjs.PreloadJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type {String}
	 * @static
	 **/
	s.version = /*=version*/&quot;NEXT&quot;; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type {String}
	 * @static
	 **/
	s.buildDate = /*=date*/&quot;Fri, 04 Dec 2015 17:26:39 GMT&quot;; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	MySubClass.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass&#x27;s new prototype.
 */
createjs.extend = function(subclass, superclass) {
	&quot;use strict&quot;;

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format &#x60;prefix_methodName&#x60;.
 * It is recommended to use the super class&#x27;s name as the prefix.
 * An alias to the super class&#x27;s constructor is always added in the format &#x60;prefix_constructor&#x60;.
 * This allows the subclass to call super class methods without using &#x60;function.call&#x60;, providing better performance.
 *
 * For example, if &#x60;MySubClass&#x60; extends &#x60;MySuperClass&#x60;, and both define a &#x60;draw&#x60; method, then calling &#x60;promote(MySubClass, &quot;MySuperClass&quot;)&#x60;
 * would add a &#x60;MySuperClass_constructor&#x60; method to MySubClass and promote the &#x60;draw&#x60; method on &#x60;MySuperClass&#x60; to the
 * prototype of &#x60;MySubClass&#x60; as &#x60;MySuperClass_draw&#x60;.
 *
 * This should be called after the class&#x27;s prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return &quot;Hello &quot;+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, &quot;ClassA&quot;);
 *
 * 	var foo = new ClassB(&quot;World&quot;, &quot;!?!&quot;);
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	&quot;use strict&quot;;

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&amp;&amp;Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+=&quot;_&quot;) + &quot;constructor&quot;] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) &amp;&amp; (typeof supP[n] == &quot;function&quot;)) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * &lt;h4&gt;Example&lt;/h4&gt;
 *
 *      myObject.addEventListener(&quot;change&quot;, createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
	&quot;use strict&quot;;

	/**
	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
	 * method gets called in the correct scope.
	 *
	 * Additional arguments can be passed that will be applied to the function when it is called.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      myObject.addEventListener(&quot;event&quot;, createjs.proxy(myHandler, this, arg1, arg2));
	 *
	 *      function myHandler(arg1, arg2) {
	 *           // This gets called when myObject.myCallback is executed.
	 *      }
	 *
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
	 * @public
	 * @static
	 */
	createjs.proxy = function (method, scope) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		return function () {
			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
		};
	}

}());

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	&quot;use strict&quot;;

	for (var i = 0,l=array.length; i &lt; l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	&quot;use strict&quot;;

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink &quot;EventDispatcher&quot;}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object&#x27;s state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:&lt;OL&gt;
		 * 	&lt;LI&gt; capture phase: starting from the top parent to the target&lt;/LI&gt;
		 * 	&lt;LI&gt; at target phase: currently being dispatched from the target&lt;/LI&gt;
		 * 	&lt;LI&gt; bubbling phase: from the target to the top parent&lt;/LI&gt;
		 * &lt;/OL&gt;
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink &quot;Event/preventDefault&quot;}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink &quot;Event/preventDefault&quot;}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink &quot;Event/stopPropagation&quot;}}{{/crossLink}} or
		 * {{#crossLink &quot;Event/stopImmediatePropagation&quot;}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink &quot;Event/stopImmediatePropagation&quot;}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink &quot;Event/remove&quot;}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * &lt;strong&gt;REMOVED&lt;/strong&gt;. Removed in favor of using &#x60;MySuperClass_constructor&#x60;.
	 * See {{#crossLink &quot;Utility Methods/extend&quot;}}{{/crossLink}} and {{#crossLink &quot;Utility Methods/promote&quot;}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// public methods:
	/**
	 * Sets {{#crossLink &quot;Event/defaultPrevented&quot;}}{{/crossLink}} to true if the event is cancelable.
	 * Mirrors the DOM level 2 event standard. In general, cancelable events that have &#x60;preventDefault()&#x60; called will
	 * cancel the default behaviour associated with the event.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&amp;&amp;true;
	};

	/**
	 * Sets {{#crossLink &quot;Event/propagationStopped&quot;}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink &quot;Event/propagationStopped&quot;}}{{/crossLink}} and
	 * {{#crossLink &quot;Event/immediatePropagationStopped&quot;}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener(&quot;click&quot;, function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return &quot;[Event (type=&quot;+this.type+&quot;)]&quot;;
	};

	createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	&quot;use strict&quot;;

	/**
	 * A general error {{#crossLink &quot;Event&quot;}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	function ErrorEvent(title, message, data) {
		this.Event_constructor(&quot;error&quot;);

		/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
		this.title = title;

		/**
		 * The verbose error message, containing details about the error.
		 * @property message
		 * @type String
		 */
		this.message = message;

		/**
		 * Additional data attached to an error.
		 * @property data
		 * @type {Object}
		 */
		this.data = data;
	}

	var p = createjs.extend(ErrorEvent, createjs.Event);

	p.clone = function() {
		return new createjs.ErrorEvent(this.title, this.message, this.data);
	};

	createjs.ErrorEvent = createjs.promote(ErrorEvent, &quot;Event&quot;);

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	&quot;use strict&quot;;


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink &quot;EventDispatcher/initialize&quot;}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink &quot;EventDispatcher/on&quot;}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink &quot;EventDispatcher/off&quot;}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink &quot;EventDispatcher/removeEventListener&quot;}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink &quot;EventDispatcher/removeAllEventListeners&quot;}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink &quot;Event/remove&quot;}}{{/crossLink}} method which removes the active listener.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 * Add EventDispatcher capabilities to the &quot;MyClass&quot; class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink &quot;EventDispatcher/addEventListener&quot;}}{{/crossLink}}).
	 *
	 *      instance.addEventListener(&quot;eventName&quot;, handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + &quot; Was Clicked&quot;);
	 *      }
	 *
	 * &lt;b&gt;Maintaining proper scope&lt;/b&gt;&lt;br /&gt;
	 * Scope (ie. &quot;this&quot;) can be be a challenge with events. Using the {{#crossLink &quot;EventDispatcher/on&quot;}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener(&quot;click&quot;, function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on(&quot;click&quot;, function(event) {
	 *          console.log(instance == this); // true, &quot;on&quot; uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage
	 * scope.
	 *
	 * &lt;b&gt;Browser support&lt;/b&gt;
	 * The event model in CreateJS can be used separately from the suite in any project, however the inheritance model
	 * requires modern browsers (IE9+).
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * &lt;strong&gt;REMOVED&lt;/strong&gt;. Removed in favor of using &#x60;MySuperClass_constructor&#x60;.
	 * See {{#crossLink &quot;Utility Methods/extend&quot;}}{{/crossLink}} and {{#crossLink &quot;Utility Methods/promote&quot;}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      displayObject.addEventListener(&quot;click&quot;, handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The wrapper function is returned for use with &#x60;removeEventListener&#x60; (or &#x60;off&#x60;).
	 * 
	 * &lt;b&gt;IMPORTANT:&lt;/b&gt; To remove a listener added with &#x60;on&#x60;, you must pass in the returned wrapper function as the listener, or use
	 * {{#crossLink &quot;Event/remove&quot;}}{{/crossLink}}. Likewise, each time you call &#x60;on&#x60; a NEW wrapper function is subscribed, so multiple calls
	 * to &#x60;on&#x60; with the same params will create multiple listeners.
	 * 
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 * 
	 * 		var listener = myBtn.on(&quot;click&quot;, handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert(&quot;clicked 3 times!&quot;);
	 * 				myBtn.off(&quot;click&quot;, listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&amp;&amp;evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * &lt;b&gt;Important Note:&lt;/b&gt; that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      displayObject.removeEventListener(&quot;click&quot;, handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i&lt;l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 * 
	 * &lt;b&gt;IMPORTANT:&lt;/b&gt; To remove a listener added with &#x60;on&#x60;, you must pass in the returned wrapper function as the listener. See 
	 * {{#crossLink &quot;EventDispatcher/on&quot;}}{{/crossLink}} for an example.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners(&quot;click&quot;);
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      // Use a string event
	 *      this.dispatchEvent(&quot;complete&quot;);
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event(&quot;progress&quot;);
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a &quot;type&quot; property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
	 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
	 * @param {Boolean} [bubbles] Specifies the &#x60;bubbles&#x60; value when a string was passed to eventObj.
	 * @param {Boolean} [cancelable] Specifies the &#x60;cancelable&#x60; value when a string was passed to eventObj.
	 * @return {Boolean} Returns false if &#x60;preventDefault()&#x60; was called on a cancelable event, true otherwise.
	 **/
	p.dispatchEvent = function(eventObj, bubbles, cancelable) {
		if (typeof eventObj == &quot;string&quot;) {
			// skip everything if there&#x27;s no listeners and it doesn&#x27;t bubble:
			var listeners = this._listeners;
			if (!bubbles &amp;&amp; (!listeners || !listeners[eventObj])) { return true; }
			eventObj = new createjs.Event(eventObj, bubbles, cancelable);
		} else if (eventObj.target &amp;&amp; eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		
		// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture &amp; atTarget
			for (i=l-1; i&gt;=0 &amp;&amp; !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i&lt;l &amp;&amp; !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return !eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners &amp;&amp; listeners[type]) || (captureListeners &amp;&amp; captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent&#x27;s parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink &quot;EventDispatcher/hasEventListener&quot;}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns &#x60;true&#x60; if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return &quot;[EventDispatcher]&quot;;
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj &amp;&amp; listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i&lt;l &amp;&amp; !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A CreateJS {{#crossLink &quot;Event&quot;}}{{/crossLink}} that is dispatched when progress changes.
	 * @class ProgressEvent
	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
	 * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the &#x60;loaded&#x60; value is
	 * a percentage (between 0 and 1), it can be omitted.
	 * @todo Consider having this event be a &quot;fileprogress&quot; event as well
	 * @constructor
	 */
	function ProgressEvent(loaded, total) {
		this.Event_constructor(&quot;progress&quot;);

		/**
		 * The amount that has been loaded (out of a total amount)
		 * @property loaded
		 * @type {Number}
		 */
		this.loaded = loaded;

		/**
		 * The total &quot;size&quot; of the load.
		 * @property total
		 * @type {Number}
		 * @default 1
		 */
		this.total = (total == null) ? 1 : total;

		/**
		 * The percentage (out of 1) that the load has been completed. This is calculated using &#x60;loaded/total&#x60;.
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = (total == 0) ? 0 : this.loaded / this.total;
	};

	var p = createjs.extend(ProgressEvent, createjs.Event);

	/**
	 * Returns a clone of the ProgressEvent instance.
	 * @method clone
	 * @return {ProgressEvent} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new createjs.ProgressEvent(this.loaded, this.total);
	};

	createjs.ProgressEvent = createjs.promote(ProgressEvent, &quot;Event&quot;);

}(window));

//##############################################################################
// json3.js
//##############################################################################

/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the &#x60;define&#x60; function exposed by asynchronous module loaders. The
  // strict &#x60;define&#x60; check is necessary for compatibility with &#x60;r.js&#x60;.
  var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    &quot;function&quot;: true,
    &quot;object&quot;: true
  };

  // Detect the &#x60;exports&#x60; object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  // Use the &#x60;global&#x60; object exposed by Node (including Browserify via
  // &#x60;insert-module-globals&#x60;), Narwhal, and Ringo as the default context,
  // and the &#x60;window&#x60; object in browsers. Rhino exports a &#x60;global&#x60; function
  // instead.
  var root = objectTypes[typeof window] &amp;&amp; window || this,
      freeGlobal = freeExports &amp;&amp; objectTypes[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; typeof global == &quot;object&quot; &amp;&amp; global;

  if (freeGlobal &amp;&amp; (freeGlobal[&quot;global&quot;] === freeGlobal || freeGlobal[&quot;window&quot;] === freeGlobal || freeGlobal[&quot;self&quot;] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given &#x60;context&#x60; object, attaching the
  // &#x60;stringify&#x60; and &#x60;parse&#x60; functions to the specified &#x60;exports&#x60; object.
  function runInContext(context, exports) {
    context || (context = root[&quot;Object&quot;]());
    exports || (exports = root[&quot;Object&quot;]());

    // Native constructor aliases.
    var Number = context[&quot;Number&quot;] || root[&quot;Number&quot;],
        String = context[&quot;String&quot;] || root[&quot;String&quot;],
        Object = context[&quot;Object&quot;] || root[&quot;Object&quot;],
        Date = context[&quot;Date&quot;] || root[&quot;Date&quot;],
        SyntaxError = context[&quot;SyntaxError&quot;] || root[&quot;SyntaxError&quot;],
        TypeError = context[&quot;TypeError&quot;] || root[&quot;TypeError&quot;],
        Math = context[&quot;Math&quot;] || root[&quot;Math&quot;],
        nativeJSON = context[&quot;JSON&quot;] || root[&quot;JSON&quot;];

    // Delegate to the native &#x60;stringify&#x60; and &#x60;parse&#x60; implementations.
    if (typeof nativeJSON == &quot;object&quot; &amp;&amp; nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the &#x60;Date#getUTC*&#x60; methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The &#x60;getUTCFullYear&#x60;, &#x60;Month&#x60;, and &#x60;Date&#x60; methods return nonsensical
      // results for certain dates in Opera &gt;= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
        // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native &#x60;JSON.stringify&#x60; and &#x60;parse&#x60;
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == &quot;bug-string-char-index&quot;) {
        // IE &lt;= 7 doesn&#x27;t support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = &quot;a&quot;[0] != &quot;a&quot;;
      } else if (name == &quot;json&quot;) {
        // Indicates whether both &#x60;JSON.stringify&#x60; and &#x60;JSON.parse&#x60; are
        // supported.
        isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
      } else {
        var value, serialized = &#x27;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&#x27;;
        // Test &#x60;JSON.stringify&#x60;.
        if (name == &quot;json-stringify&quot;) {
          var stringify = exports.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
          if (stringifySupported) {
            // A test function object with a custom &#x60;toJSON&#x60; method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === &quot;0&quot; &amp;&amp;
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === &quot;0&quot; &amp;&amp;
                stringify(new String()) == &#x27;&quot;&quot;&#x27; &amp;&amp;
                // FF 3.1b1, 2 throw an error if the value is &#x60;null&#x60;, &#x60;undefined&#x60;, or
                // does not define a canonical JSON representation (this applies to
                // objects with &#x60;toJSON&#x60; properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &amp;&amp;
                // IE 8 serializes &#x60;undefined&#x60; as &#x60;&quot;undefined&quot;&#x60;. Safari &lt;= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &amp;&amp;
                // Safari &lt;= 5.1.7 and FF 3.1b3 throw &#x60;Error&#x60;s and &#x60;TypeError&#x60;s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &amp;&amp;
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or &#x60;null&#x60; literal. This applies to
                // objects with custom &#x60;toJSON&#x60; methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom &#x60;toJSON&#x60;
                // methods entirely.
                stringify(value) === &quot;1&quot; &amp;&amp;
                stringify([value]) == &quot;[1]&quot; &amp;&amp;
                // Prototype &lt;= 1.6.1 serializes &#x60;[undefined]&#x60; as &#x60;&quot;[]&quot;&#x60; instead of
                // &#x60;&quot;[null]&quot;&#x60;.
                stringify([undef]) == &quot;[null]&quot; &amp;&amp;
                // YUI 3.0.0b1 fails to serialize &#x60;null&#x60; literals.
                stringify(null) == &quot;null&quot; &amp;&amp;
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // &#x60;[1, true, getClass, 1]&#x60; serializes as &quot;[1,true,],&quot;. FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom &#x60;toJSON&#x60; methods.
                stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., &#x60;\b&#x60; =&gt; &#x60;\u0008&#x60;).
                stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
                // FF 3.1b1 and b2 ignore the &#x60;filter&#x60; and &#x60;width&#x60; arguments.
                stringify(null, value) === &quot;1&quot; &amp;&amp;
                stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
                // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == &#x27;&quot;-271821-04-20T00:00:00.000Z&quot;&#x27; &amp;&amp;
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == &#x27;&quot;+275760-09-13T00:00:00.000Z&quot;&#x27; &amp;&amp;
                // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == &#x27;&quot;-000001-01-01T00:00:00.000Z&quot;&#x27; &amp;&amp;
                // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == &#x27;&quot;1969-12-31T23:59:59.999Z&quot;&#x27;;
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test &#x60;JSON.parse&#x60;.
        if (name == &quot;json-parse&quot;) {
          var parse = exports.parse;
          if (typeof parse == &quot;function&quot;) {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse(&#x27;&quot;\t&quot;&#x27;);
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading &#x60;+&#x60; signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse(&quot;01&quot;) !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse(&quot;1.&quot;) !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has(&quot;json&quot;)) {
      // Common &#x60;[[Class]]&#x60; name aliases.
      var functionClass = &quot;[object Function]&quot;,
          dateClass = &quot;[object Date]&quot;,
          numberClass = &quot;[object Number]&quot;,
          stringClass = &quot;[object String]&quot;,
          arrayClass = &quot;[object Array]&quot;,
          booleanClass = &quot;[object Boolean]&quot;;

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has(&quot;bug-string-char-index&quot;);

      // Define additional utility methods if the &#x60;Date&#x60; methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native &#x60;Object#hasOwnProperty&#x60; method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            &quot;toString&quot;: 1
          }, members).toString != getClass) {
            // Safari &lt;= 2.0.3 doesn&#x27;t implement &#x60;Object#hasOwnProperty&#x60;, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object&#x27;s prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level &#x60;Object&#x60; constructor.
            constructor = members.constructor;
            // Use the &#x60;constructor&#x60; property to simulate &#x60;Object#hasOwnProperty&#x60; in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the &#x60;for...in&#x60; iteration algorithm across
      // environments. Each enumerated key is yielded to a &#x60;callback&#x60; function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment&#x27;s &#x60;for...in&#x60; algorithm. The
        // &#x60;valueOf&#x60; property inherits the non-enumerable flag from
        // &#x60;Object.prototype&#x60; in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the &#x60;Properties&#x60; class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from &#x60;Object.prototype&#x60;.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from &#x60;Object.prototype&#x60;.
          members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
          // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &quot;function&quot; &amp;&amp; objectTypes[typeof object.hasOwnProperty] &amp;&amp; object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko &lt;= 1.0 enumerates the &#x60;prototype&#x60; property of functions under
              // certain conditions; IE does not.
              if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
          };
        } else if (size == 2) {
          // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // &#x60;prototype&#x60; property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard &#x60;for...in&#x60; algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
                callback(property);
              }
            }
            // Manually invoke the callback for the &#x60;constructor&#x60; property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript &#x60;value&#x60; as a JSON string. The optional
      // &#x60;filter&#x60; argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional &#x60;width&#x60;
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has(&quot;json-stringify&quot;)) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: &quot;\\\\&quot;,
          34: &#x27;\\&quot;&#x27;,
          8: &quot;\\b&quot;,
          12: &quot;\\f&quot;,
          10: &quot;\\n&quot;,
          13: &quot;\\r&quot;,
          9: &quot;\\t&quot;
        };

        // Internal: Converts &#x60;value&#x60; into a zero-padded string such that its
        // length is at least equal to &#x60;width&#x60;. The &#x60;width&#x60; must be &lt;= 6.
        var leadingZeroes = &quot;000000&quot;;
        var toPaddedString = function (width, value) {
          // The &#x60;|| 0&#x60; expression is necessary to work around a bug in
          // Opera &lt;= 7.54u2 where &#x60;0 == -0&#x60;, but &#x60;String(-0) !== &quot;0&quot;&#x60;.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string &#x60;value&#x60;, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // &#x60;Quote(value)&#x60; operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = &quot;\\u00&quot;;
        var quote = function (value) {
          var result = &#x27;&quot;&#x27;, index = 0, length = value.length, useCharIndex = !charIndexBuggy || length &gt; 10;
          var symbols = useCharIndex &amp;&amp; (charIndexBuggy ? value.split(&quot;&quot;) : value);
          for (; index &lt; length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode &lt; 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + &#x27;&quot;&#x27;;
        };

        // Internal: Recursively serializes an object. Implements the
        // &#x60;Str(key, holder)&#x60;, &#x60;JO(value)&#x60;, and &#x60;JA(value)&#x60; operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == &quot;object&quot; &amp;&amp; value) {
            className = getClass.call(value);
            if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
              if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
                // Dates are serialized according to the &#x60;Date#toJSON&#x60; method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the &#x60;getUTC*&#x60; methods are
                  // buggy. Adapted from @Yaffle&#x27;s &#x60;date-shim&#x60; project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The &#x60;time&#x60; value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula &#x60;(A % B + B) % B&#x60; is used
                  // to compute &#x60;A modulo B&#x60;, as the &#x60;%&#x60; operator does not
                  // correspond to the &#x60;modulo&#x60; operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                  &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
              // Prototype &lt;= 1.6.1 adds non-standard &#x60;toJSON&#x60; methods to the
              // &#x60;Number&#x60;, &#x60;String&#x60;, &#x60;Date&#x60;, and &#x60;Array&#x60; prototypes. JSON 3
              // ignores all &#x60;toJSON&#x60; methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return &quot;null&quot;;
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return &quot;&quot; + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. &#x60;Infinity&#x60; and &#x60;NaN&#x60; are serialized as
            // &#x60;&quot;null&quot;&#x60;.
            return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote(&quot;&quot; + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == &quot;object&quot;) {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by &#x60;JSON.stringify&#x60;.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index &lt; length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? &quot;null&quot; : element);
              }
              result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: &quot;If &#x60;gap&#x60; {whitespace}
                  // is not the empty string, let &#x60;member&#x60; {quote(property) + &quot;:&quot;}
                  // be the concatenation of &#x60;member&#x60; and the &#x60;space&#x60; character.&quot;
                  // The &quot;&#x60;space&#x60; character&quot; refers to the literal space
                  // character, not the &#x60;space&#x60; {width} argument provided to
                  // &#x60;JSON.stringify&#x60;.
                  results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
                }
              });
              result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: &#x60;JSON.stringify&#x60;. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] &amp;&amp; filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the &#x60;width&#x60; to an integer and create a string containing
              // &#x60;width&#x60; number of space characters.
              if ((width -= width % 1) &gt; 0) {
                for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
              }
            } else if (className == stringClass) {
              whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera &lt;= 7.54u2 discards the values associated with empty string keys
          // (&#x60;&quot;&quot;&#x60;) only if they are used directly within an object member list
          // (e.g., &#x60;!(&quot;&quot; in { &quot;&quot;: 1})&#x60;).
          return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has(&quot;json-parse&quot;)) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: &quot;\\&quot;,
          34: &#x27;&quot;&#x27;,
          47: &quot;/&quot;,
          98: &quot;\b&quot;,
          116: &quot;\t&quot;,
          110: &quot;\n&quot;,
          102: &quot;\f&quot;,
          114: &quot;\r&quot;
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a &#x60;SyntaxError&#x60;.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or &#x60;&quot;$&quot;&#x60; if the parser has reached
        // the end of the source string. A token may be a string, number, &#x60;null&#x60;
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index &lt; length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (&#x60;{&#x60;, &#x60;}&#x60;, &#x60;[&#x60;, &#x60;]&#x60;, &#x60;:&#x60;, or &#x60;,&#x60;) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // &#x60;&quot;&#x60; delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel &#x60;@&#x60; character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode &lt; 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (&#x60;\&#x60;) marks the beginning of an escaped
                    // control character (including &#x60;&quot;&#x60;, &#x60;\&#x60;, and &#x60;/&#x60;) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // &#x60;\u&#x60; marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index &lt; position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The &#x60;e&#x60; denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // &#x60;true&#x60;, &#x60;false&#x60;, and &#x60;null&#x60; literals.
                if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel &#x60;$&#x60; character if the parser has reached the end
          // of the source string.
          return &quot;$&quot;;
        };

        // Internal: Parses a JSON &#x60;value&#x60; token.
        var get = function (value) {
          var results, hasMembers;
          if (value == &quot;$&quot;) {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == &quot;string&quot;) {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
              // Remove the sentinel &#x60;@&#x60; character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == &quot;[&quot;) {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == &quot;]&quot;) {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == &quot;,&quot;) {
                    value = lex();
                    if (value == &quot;]&quot;) {
                      // Unexpected trailing &#x60;,&#x60; in array literal.
                      abort();
                    }
                  } else {
                    // A &#x60;,&#x60; must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == &quot;,&quot;) {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == &quot;{&quot;) {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == &quot;}&quot;) {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == &quot;,&quot;) {
                    value = lex();
                    if (value == &quot;}&quot;) {
                      // Unexpected trailing &#x60;,&#x60; in object literal.
                      abort();
                    }
                  } else {
                    // A &#x60;,&#x60; must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a &#x60;:&#x60; must separate each property
                // name and value.
                if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // &#x60;callback&#x60; function for each value. This is an implementation of the
        // &#x60;Walk(holder, name)&#x60; operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == &quot;object&quot; &amp;&amp; value) {
            // &#x60;forEach&#x60; can&#x27;t be used to traverse an array in Opera &lt;= 8.54
            // because its &#x60;Object#hasOwnProperty&#x60; implementation returns &#x60;false&#x60;
            // for array indices (e.g., &#x60;![1, 2, 3].hasOwnProperty(&quot;0&quot;)&#x60;).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: &#x60;JSON.parse&#x60;. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = &quot;&quot; + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != &quot;$&quot;) {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
        };
      }
    }

    exports[&quot;runInContext&quot;] = runInContext;
    return exports;
  }

  if (freeExports &amp;&amp; !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root[&quot;JSON3&quot;],
        isRestored = false;

    var JSON3 = runInContext(root, (root[&quot;JSON3&quot;] = {
      // Public: Restores the original value of the global &#x60;JSON&#x60; object and
      // returns a reference to the &#x60;JSON3&#x60; object.
      &quot;noConflict&quot;: function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root[&quot;JSON3&quot;] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      &quot;parse&quot;: JSON3.parse,
      &quot;stringify&quot;: JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

//##############################################################################
// DomUtils.js
//##############################################################################

(function () {

	/**
	 * A few utilities for interacting with the dom.
	 * @class DomUtils
	 */
	var s = {};

	s.appendToHead = function (el) {
		s.getHead().appendChild(el)
	}

	s.getHead = function () {
		return document.head || document.getElementsByTagName(&quot;head&quot;)[0];
	}

	s.getBody = function () {
		return document.body || document.getElementsByTagName(&quot;body&quot;)[0];
	}

	createjs.DomUtils = s;

}());

//##############################################################################
// DataUtils.js
//##############################################################################

(function () {

	/**
	 * A few data utilities for formatting different data types.
	 * @class DataUtils
	 */
	var s = {};

	// static methods
	/**
	 * Parse XML using the DOM. This is required when preloading XML or SVG.
	 * @method parseXML
	 * @param {String} text The raw text or XML that is loaded by XHR.
	 * @param {String} type The mime type of the XML. Use &quot;text/xml&quot; for XML, and  &quot;image/svg+xml&quot; for SVG parsing.
	 * @return {XML} An XML document
	 * @static
	 */
	s.parseXML = function (text, type) {
		var xml = null;
		// CocoonJS does not support XML parsing with either method.

		// Most browsers will use DOMParser
		// IE fails on certain SVG files, so we have a fallback below.
		try {
			if (window.DOMParser) {
				var parser = new DOMParser();
				xml = parser.parseFromString(text, type);
			}
		} catch (e) {
		}

		// Fallback for IE support.
		if (!xml) {
			try {
				xml = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);
				xml.async = false;
				xml.loadXML(text);
			} catch (e) {
				xml = null;
			}
		}

		return xml;
	};

	/**
	 * Parse a string into an Object.
	 * @method parseJSON
	 * @param {String} value The loaded JSON string
	 * @returns {Object} A JavaScript object.
	 */
	s.parseJSON = function (value) {
		if (value == null) {
			return null;
		}

		try {
			return JSON.parse(value);
		} catch (e) {
			// TODO; Handle this with a custom error?
			throw e;
		}
	};

	createjs.DataUtils = s;

}());

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	/**
	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
	 * it will not be affected, but it must contain at least a {{#crossLink &quot;src:property&quot;}}{{/crossLink}} property. A
	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
	 * {{#crossLink &quot;create&quot;}}{{/crossLink}} method by {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}}
	 * @class LoadItem
	 * @constructor
	 * @since 0.6.0
	 */
	function LoadItem() {
		/**
		 * The source of the file that is being loaded. This property is &lt;b&gt;required&lt;/b&gt;. The source can either be a
		 * string (recommended), or an HTML tag.
		 * This can also be an object, but in that case it has to include a type and be handled by a plugin.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = null;

		/**
		 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
		 * be set manually. This is helpful in cases where a file does not have an extension.
		 * @property type
		 * @type {String}
		 * @default null
		 */
		this.type = null;

		/**
		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
		 * automatically set to the {{#crossLink &quot;src:property&quot;}}{{/crossLink}}.
		 * @property id
		 * @type {String}
		 * @default null
		 */
		this.id = null;

		/**
		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
		 * that have also set the &#x60;maintainOrder&#x60; property to &#x60;true&#x60;. This only applies when the max connections has
		 * been set above 1 (using {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}}). Everything with this
		 * property set to &#x60;false&#x60; will finish as it is loaded. Ordered items are combined with script tags loading in
		 * order when {{#crossLink &quot;LoadQueue/maintainScriptOrder:property&quot;}}{{/crossLink}} is set to &#x60;true&#x60;.
		 * @property maintainOrder
		 * @type {Boolean}
		 * @default false
		 */
		this.maintainOrder = false;

		/**
		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
		 * @property callback
		 * @type {String}
		 * @default null
		 */
		this.callback = null;

		/**
		 * An arbitrary data object, which is included with the loaded object.
		 * @property data
		 * @type {Object}
		 * @default null
		 */
		this.data = null;

		/**
		 * The request method used for HTTP calls. Both {{#crossLink &quot;AbstractLoader/GET:property&quot;}}{{/crossLink}} or
		 * {{#crossLink &quot;AbstractLoader/POST:property&quot;}}{{/crossLink}} request types are supported, and are defined as
		 * constants on {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}}.
		 * @property method
		 * @type {String}
		 * @default get
		 */
		this.method = createjs.LoadItem.GET;

		/**
		 * An object hash of name/value pairs to send to the server.
		 * @property values
		 * @type {Object}
		 * @default null
		 */
		this.values = null;

		/**
		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
		 * headers when required, including &quot;Origin&quot;, &quot;Content-Type&quot;, and &quot;X-Requested-With&quot;. You may override the
		 * default headers by including them in your headers object.
		 * @property headers
		 * @type {Object}
		 * @default null
		 */
		this.headers = null;

		/**
		 * Enable credentials for XHR requests.
		 * @property withCredentials
		 * @type {Boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * Set the mime type of XHR-based requests. This is automatically set to &quot;text/plain; charset=utf-8&quot; for text
		 * based files (json, xml, text, css, js).
		 * @property mimeType
		 * @type {String}
		 * @default null
		 */
		this.mimeType = null;

		/**
		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
		 * @property crossOrigin
		 * @type {boolean}
		 * @default Anonymous
		 */
		this.crossOrigin = null;

		/**
		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
		 * (level one) loading, as XHR (level 2) provides its own timeout event.
		 * @property loadTimeout
		 * @type {Number}
		 * @default 8000 (8 seconds)
		 */
		this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
	};

	var p = LoadItem.prototype = {};
	var s = LoadItem;

	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 * @property LOAD_TIMEOUT_DEFAULT
	 * @type {number}
	 * @static
	 */
	s.LOAD_TIMEOUT_DEFAULT = 8000;

	/**
	 * Create a LoadItem.
	 * &lt;ul&gt;
	 *     &lt;li&gt;String-based items are converted to a LoadItem with a populated {{#crossLink &quot;src:property&quot;}}{{/crossLink}}.&lt;/li&gt;
	 *     &lt;li&gt;LoadItem instances are returned as-is&lt;/li&gt;
	 *     &lt;li&gt;Objects are returned with any needed properties added&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @method create
	 * @param {LoadItem|String|Object} value The load item value
	 * @returns {LoadItem|Object}
	 * @static
	 */
	s.create = function (value) {
		if (typeof value == &quot;string&quot;) {
			var item = new LoadItem();
			item.src = value;
			return item;
		} else if (value instanceof s) {
			return value;
		} else if (value instanceof Object &amp;&amp; value.src) {
			if (value.loadTimeout == null) {
				value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
			}
			return value;
		} else {
			throw new Error(&quot;Type not recognized.&quot;);
		}
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      var loadItem = new createjs.LoadItem().set({src:&quot;image.png&quot;, maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

	/**
	 * Utilities that assist with parsing load items, and determining file types, etc.
	 * @class RequestUtils
	 */
	var s = {};

	/**
	 * The Regular Expression used to test file URLS for an absolute path.
	 * @property ABSOLUTE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

	/**
	 * The Regular Expression used to test file URLS for a relative path.
	 * @property RELATIVE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.RELATIVE_PATT = (/^[./]*?\//i);

	/**
	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
	 * removed.
	 * @property EXTENSION_PATT
	 * @type {RegExp}
	 * @static
	 */
	s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

	/**
	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
	 * &lt;ul&gt;
	 *     &lt;li&gt;If the path is absolute. Absolute paths start with a protocol (such as &#x60;http://&#x60;, &#x60;file://&#x60;, or
	 *     &#x60;//networkPath&#x60;)&lt;/li&gt;
	 *     &lt;li&gt;If the path is relative. Relative paths start with &#x60;../&#x60; or &#x60;/path&#x60; (or similar)&lt;/li&gt;
	 *     &lt;li&gt;The file extension. This is determined by the filename with an extension. Query strings are dropped, and
	 *     the file path is expected to follow the format &#x60;name.ext&#x60;.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @method parseURI
	 * @param {String} path
	 * @returns {Object} An Object with an &#x60;absolute&#x60; and &#x60;relative&#x60; Boolean values, as well as an optional &#x27;extension&#x60;
	 * property, which is the lowercase extension.
	 * @static
	 */
	s.parseURI = function (path) {
		var info = {absolute: false, relative: false};
		if (path == null) { return info; }

		// Drop the query string
		var queryIndex = path.indexOf(&quot;?&quot;);
		if (queryIndex &gt; -1) {
			path = path.substr(0, queryIndex);
		}

		// Absolute
		var match;
		if (s.ABSOLUTE_PATT.test(path)) {
			info.absolute = true;

			// Relative
		} else if (s.RELATIVE_PATT.test(path)) {
			info.relative = true;
		}

		// Extension
		if (match = path.match(s.EXTENSION_PATT)) {
			info.extension = match[1].toLowerCase();
		}
		return info;
	};

	/**
	 * Formats an object into a query string for either a POST or GET request.
	 * @method formatQueryString
	 * @param {Object} data The data to convert to a query string.
	 * @param {Array} [query] Existing name/value pairs to append on to this query.
	 * @static
	 */
	s.formatQueryString = function (data, query) {
		if (data == null) {
			throw new Error(&#x27;You must specify data.&#x27;);
		}
		var params = [];
		for (var n in data) {
			params.push(n + &#x27;=&#x27; + escape(data[n]));
		}
		if (query) {
			params = params.concat(query);
		}
		return params.join(&#x27;&amp;&#x27;);
	};

	/**
	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.
	 * @method buildPath
	 * @param {String} src The source path to add values to.
	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
	 * path will be preserved.
	 * @returns {string} A formatted string that contains the path and the supplied parameters.
	 * @static
	 */
	s.buildPath = function (src, data) {
		if (data == null) {
			return src;
		}

		var query = [];
		var idx = src.indexOf(&#x27;?&#x27;);

		if (idx != -1) {
			var q = src.slice(idx + 1);
			query = query.concat(q.split(&#x27;&amp;&#x27;));
		}

		if (idx != -1) {
			return src.slice(0, idx) + &#x27;?&#x27; + this.formatQueryString(data, query);
		} else {
			return src + &#x27;?&#x27; + this.formatQueryString(data, query);
		}
	};

	/**
	 * @method isCrossDomain
	 * @param {LoadItem|Object} item A load item with a &#x60;src&#x60; property.
	 * @return {Boolean} If the load item is loading from a different domain than the current location.
	 * @static
	 */
	s.isCrossDomain = function (item) {
		var target = document.createElement(&quot;a&quot;);
		target.href = item.src;

		var host = document.createElement(&quot;a&quot;);
		host.href = location.href;

		var crossdomain = (target.hostname != &quot;&quot;) &amp;&amp;
						  (target.port != host.port ||
						   target.protocol != host.protocol ||
						   target.hostname != host.hostname);
		return crossdomain;
	};

	/**
	 * @method isLocal
	 * @param {LoadItem|Object} item A load item with a &#x60;src&#x60; property
	 * @return {Boolean} If the load item is loading from the &quot;file:&quot; protocol. Assume that the host must be local as
	 * well.
	 * @static
	 */
	s.isLocal = function (item) {
		var target = document.createElement(&quot;a&quot;);
		target.href = item.src;
		return target.hostname == &quot;&quot; &amp;&amp; target.protocol == &quot;file:&quot;;
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as &quot;binary&quot; are loaded as binary. Note that audio is &lt;b&gt;not&lt;/b&gt; a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
	 * {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}}.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @static
	 */
	s.isBinary = function (type) {
		switch (type) {
			case createjs.AbstractLoader.IMAGE:
			case createjs.AbstractLoader.BINARY:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Check if item is a valid HTMLImageElement
	 * @method isImageTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isImageTag = function(item) {
		return item instanceof HTMLImageElement;
	};

	/**
	 * Check if item is a valid HTMLAudioElement
	 * @method isAudioTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isAudioTag = function(item) {
		if (window.HTMLAudioElement) {
			return item instanceof HTMLAudioElement;
		} else {
			return false;
		}
	};

	/**
	 * Check if item is a valid HTMLVideoElement
	 * @method isVideoTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isVideoTag = function(item) {
		if (window.HTMLVideoElement) {
			return item instanceof HTMLVideoElement;
		} else {
			return false;
		}
	};

	/**
	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @static
	 */
	s.isText = function (type) {
		switch (type) {
			case createjs.AbstractLoader.TEXT:
			case createjs.AbstractLoader.JSON:
			case createjs.AbstractLoader.MANIFEST:
			case createjs.AbstractLoader.XML:
			case createjs.AbstractLoader.CSS:
			case createjs.AbstractLoader.SVG:
			case createjs.AbstractLoader.JAVASCRIPT:
			case createjs.AbstractLoader.SPRITESHEET:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @method getTypeByExtension
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, &lt;code&gt;AbstractLoader.IMAGE&lt;/code&gt;). Will return &#x60;null&#x60; if
	 * the type can not be determined by the extension.
	 * @static
	 */
	s.getTypeByExtension = function (extension) {
		if (extension == null) {
			return createjs.AbstractLoader.TEXT;
		}

		switch (extension.toLowerCase()) {
			case &quot;jpeg&quot;:
			case &quot;jpg&quot;:
			case &quot;gif&quot;:
			case &quot;png&quot;:
			case &quot;webp&quot;:
			case &quot;bmp&quot;:
				return createjs.AbstractLoader.IMAGE;
			case &quot;ogg&quot;:
			case &quot;mp3&quot;:
			case &quot;webm&quot;:
				return createjs.AbstractLoader.SOUND;
			case &quot;mp4&quot;:
			case &quot;webm&quot;:
			case &quot;ts&quot;:
				return createjs.AbstractLoader.VIDEO;
			case &quot;json&quot;:
				return createjs.AbstractLoader.JSON;
			case &quot;xml&quot;:
				return createjs.AbstractLoader.XML;
			case &quot;css&quot;:
				return createjs.AbstractLoader.CSS;
			case &quot;js&quot;:
				return createjs.AbstractLoader.JAVASCRIPT;
			case &#x27;svg&#x27;:
				return createjs.AbstractLoader.SVG;
			default:
				return createjs.AbstractLoader.TEXT;
		}
	};

	createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

// constructor
	/**
	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	 * including the {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}}.
	 * @class AbstractLoader
	 * @param {LoadItem|object|string} loadItem The item to be loaded.
	 * @param {Boolean} [preferXHR] Determines if the LoadItem should &lt;em&gt;try&lt;/em&gt; and load using XHR, or take a
	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	 * other, so this is a suggested directive.
	 * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	 * such as {{#crossLink &quot;IMAGE:property&quot;}}{{/crossLink}}, {{#crossLink &quot;CSS:property&quot;}}{{/crossLink}}, etc.
	 * @extends EventDispatcher
	 */
	function AbstractLoader(loadItem, preferXHR, type) {
		this.EventDispatcher_constructor();

		// public properties
		/**
		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
		 * used for loading do not pile up resulting in more than one &#x60;complete&#x60; {{#crossLink &quot;Event&quot;}}{{/crossLink}}.
		 * @property loaded
		 * @type {Boolean}
		 * @default false
		 */
		this.loaded = false;

		/**
		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
		 * is readonly, so {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} queues should be closed using {{#crossLink &quot;LoadQueue/close&quot;}}{{/crossLink}}
		 * instead.
		 * @property canceled
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 */
		this.canceled = false;

		/**
		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
		 *
		 * &lt;h4&gt;Example&lt;/h4&gt;
		 *
		 *     var queue = new createjs.LoadQueue();
		 *     queue.loadFile(&quot;largeImage.png&quot;);
		 *     queue.on(&quot;progress&quot;, function() {
		 *         console.log(&quot;Progress:&quot;, queue.progress, event.progress);
		 *     });
		 *
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = 0;

		/**
		 * The type of item this loader will load. See {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}} for a full list of
		 * supported types.
		 * @property type
		 * @type {String}
		 */
		this.type = type;

		/**
		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
		 * can be overridden to provide custom formatting.
		 *
		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
		 * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks
		 * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is
		 * called in the current scope, as well as the success and error callbacks.
		 *
		 * &lt;h4&gt;Example asynchronous resultFormatter&lt;/h4&gt;
		 *
		 * 	function _formatResult(loader) {
		 * 		return function(success, error) {
		 * 			if (errorCondition) { error(errorDetailEvent); }
		 * 			success(result);
		 * 		}
		 * 	}
		 * @property resultFormatter
		 * @type {Function}
		 * @default null
		 */
		this.resultFormatter = null;

		// protected properties
		/**
		 * The {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}},
		 * but will be available on loaders such as {{#crossLink &quot;XMLLoader&quot;}}{{/crossLink}} and {{#crossLink &quot;ImageLoader&quot;}}{{/crossLink}}.
		 * @property _item
		 * @type {LoadItem|Object}
		 * @private
		 */
		if (loadItem) {
			this._item = createjs.LoadItem.create(loadItem);
		} else {
			this._item = null;
		}

		/**
		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).
		 * @property _preferXHR
		 * @type {Boolean}
		 * @private
		 */
		this._preferXHR = preferXHR;

		/**
		 * The loaded result after it is formatted by an optional {{#crossLink &quot;resultFormatter&quot;}}{{/crossLink}}. For
		 * items that are not formatted, this will be the same as the {{#crossLink &quot;_rawResult:property&quot;}}{{/crossLink}}.
		 * The result is accessed using the {{#crossLink &quot;getResult&quot;}}{{/crossLink}} method.
		 * @property _result
		 * @type {Object|String}
		 * @private
		 */
		this._result = null;

		/**
		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink &quot;getResult&quot;}}{{/crossLink}}
		 * method, and passing &#x60;true&#x60;.
		 * @property _rawResult
		 * @type {Object|String}
		 * @private
		 */
		this._rawResult = null;

		/**
		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink &quot;SpriteSheetLoader&quot;}}{{/crossLink}} and
		 * {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}.
		 * @property _loadItems
		 * @type {null}
		 * @protected
		 */
		this._loadedItems = null;

		/**
		 * The attribute the items loaded using tags use for the source.
		 * @type {string}
		 * @default null
		 * @private
		 */
		this._tagSrcAttribute = null;

		/**
		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
		 * @property _tag
		 * @type {Object}
		 * @private
		 */
		this._tag = null;
	};

	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
	var s = AbstractLoader;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Defines a POST request, use for a method value when loading data.
	 * @property POST
	 * @type {string}
	 * @default post
	 * @static
	 */
	s.POST = &quot;POST&quot;;

	/**
	 * Defines a GET request, use for a method value when loading data.
	 * @property GET
	 * @type {string}
	 * @default get
	 * @static
	 */
	s.GET = &quot;GET&quot;;

	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @since 0.6.0
	 */
	s.BINARY = &quot;binary&quot;;

	/**
	 * The preload type for css files. CSS files are loaded using a &amp;lt;link&amp;gt; when loaded with XHR, or a
	 * &amp;lt;style&amp;gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @since 0.6.0
	 */
	s.CSS = &quot;css&quot;;

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &amp;lt;image&amp;gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @since 0.6.0
	 */
	s.IMAGE = &quot;image&quot;;

	/**
	 * The preload type for javascript files, usually with the &quot;js&quot; file extension. JavaScript files are loaded into a
	 * &amp;lt;script&amp;gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @since 0.6.0
	 */
	s.JAVASCRIPT = &quot;javascript&quot;;

	/**
	 * The preload type for json files, usually with the &quot;json&quot; file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a &#x60;callback&#x60; is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink &quot;LoadQueue/preferXHR:property&quot;}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @since 0.6.0
	 */
	s.JSON = &quot;json&quot;;

	/**
	 * The preload type for jsonp files, usually with the &quot;json&quot; file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink &quot;LoadQueue/preferXHR:property&quot;}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @since 0.6.0
	 */
	s.JSONP = &quot;jsonp&quot;;

	/**
	 * The preload type for json-based manifest files, usually with the &quot;json&quot; file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a &quot;manifest&quot; property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}
	 * method. If a &quot;callback&quot; is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink &quot;LoadQueue/preferXHR:property&quot;}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.6.0
	 */
	s.MANIFEST = &quot;manifest&quot;;

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &amp;lt;audio&amp;gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @since 0.6.0
	 */
	s.SOUND = &quot;sound&quot;;

	/**
	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
	 * &amp;lt;video&amp;gt; tag.
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @since 0.6.0
	 */
	s.VIDEO = &quot;video&quot;;

	/**
	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
	 * @property SPRITESHEET
	 * @type {String}
	 * @default spritesheet
	 * @static
	 * @since 0.6.0
	 */
	s.SPRITESHEET = &quot;spritesheet&quot;;

	/**
	 * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @since 0.6.0
	 */
	s.SVG = &quot;svg&quot;;

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @since 0.6.0
	 */
	s.TEXT = &quot;text&quot;;

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @since 0.6.0
	 */
	s.XML = &quot;xml&quot;;

// Events
	/**
	 * The {{#crossLink &quot;ProgressEvent&quot;}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink &quot;Event&quot;}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink &quot;Event&quot;}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */

	/**
	 * The {{#crossLink &quot;Event&quot;}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink &quot;ErrorEvent&quot;}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink &quot;Event&quot;}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink &quot;Event&quot;}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The even type (&quot;fileerror&quot;)
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink &quot;Event&quot;}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}} to maintain internal {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type (&quot;fileload&quot;)
	 * @param {Object} item The file item which was specified in the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a &#x60;src&#x60; property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink &quot;Event&quot;}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type (&quot;initialize&quot;)
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */


	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} or
	 * {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}.
	 * @method getItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	p.getItem = function () {
		return this._item;
	};

	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink &quot;complete:event&quot;}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	p.getResult = function (raw) {
		return raw ? this._rawResult : this._result;
	};

	/**
	 * Return the &#x60;tag&#x60; this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	p.getTag = function () {
		return this._tag;
	};

	/**
	 * Set the &#x60;tag&#x60; this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	p.setTag = function(tag) {
	  this._tag = tag;
	};

	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.on(&quot;complete&quot;, handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	p.load = function () {
		this._createRequest();

		this._request.on(&quot;complete&quot;, this, this);
		this._request.on(&quot;progress&quot;, this, this);
		this._request.on(&quot;loadStart&quot;, this, this);
		this._request.on(&quot;abort&quot;, this, this);
		this._request.on(&quot;timeout&quot;, this, this);
		this._request.on(&quot;error&quot;, this, this);

		var evt = new createjs.Event(&quot;initialize&quot;);
		evt.loader = this._request;
		this.dispatchEvent(evt);

		this._request.load();
	};

	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	p.cancel = function () {
		this.canceled = true;
		this.destroy();
	};

	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	p.destroy = function() {
		if (this._request) {
			this._request.removeAllEventListeners();
			this._request.destroy();
		}

		this._request = null;

		this._item = null;
		this._rawResult = null;
		this._result = null;

		this._loadItems = null;

		this.removeAllEventListeners();
	};

	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	p.getLoadedItems = function () {
		return this._loadedItems;
	};


	// Private methods
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink &quot;XHRRequest&quot;}}{{/crossLink}} or
	 * {{#crossLink &quot;TagRequest&quot;}}{{/crossLink}} is created, depending on the value of {{#crossLink &quot;preferXHR:property&quot;}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}},
	 * which uses {{#crossLink &quot;JSONLoader&quot;}}{{/crossLink}} or {{#crossLink &quot;JSONPLoader&quot;}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	p._createTag = function(src) { return null; };

	/**
	 * Dispatch a loadstart {{#crossLink &quot;Event&quot;}}{{/crossLink}}. Please see the {{#crossLink &quot;AbstractLoader/loadstart:event&quot;}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	p._sendLoadStart = function () {
		if (this._isCanceled()) { return; }
		this.dispatchEvent(&quot;loadstart&quot;);
	};

	/**
	 * Dispatch a {{#crossLink &quot;ProgressEvent&quot;}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing &lt;code&gt;loaded&lt;/code&gt;
	 * and &lt;code&gt;total&lt;/code&gt; properties.
	 * @protected
	 */
	p._sendProgress = function (value) {
		if (this._isCanceled()) { return; }
		var event = null;
		if (typeof(value) == &quot;number&quot;) {
			this.progress = value;
			event = new createjs.ProgressEvent(this.progress);
		} else {
			event = value;
			this.progress = value.loaded / value.total;
			event.progress = this.progress;
			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
		}
		this.hasEventListener(&quot;progress&quot;) &amp;&amp; this.dispatchEvent(event);
	};

	/**
	 * Dispatch a complete {{#crossLink &quot;Event&quot;}}{{/crossLink}}. Please see the {{#crossLink &quot;AbstractLoader/complete:event&quot;}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	p._sendComplete = function () {
		if (this._isCanceled()) { return; }

		this.loaded = true;

		var event = new createjs.Event(&quot;complete&quot;);
		event.rawResult = this._rawResult;

		if (this._result != null) {
			event.result = this._result;
		}

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch an error {{#crossLink &quot;Event&quot;}}{{/crossLink}}. Please see the {{#crossLink &quot;AbstractLoader/error:event&quot;}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	p._sendError = function (event) {
		if (this._isCanceled() || !this.hasEventListener(&quot;error&quot;)) { return; }
		if (event == null) {
			event = new createjs.ErrorEvent(&quot;PRELOAD_ERROR_EMPTY&quot;); // TODO: Populate error
		}
		this.dispatchEvent(event);
	};

	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	p._isCanceled = function () {
		if (window.createjs == null || this.canceled) {
			return true;
		}
		return false;
	};

	/**
	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most
	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
	 * formatted result will be available on Loaders using {{#crossLink &quot;getResult&quot;}}{{/crossLink}}, and passing &#x60;true&#x60;.
	 * @property resultFormatter
	 * @type Function
	 * @return {Object} The formatted result
	 * @since 0.6.0
	 */
	p.resultFormatter = null;

	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	p.handleEvent = function (event) {
		switch (event.type) {
			case &quot;complete&quot;:
				this._rawResult = event.target._response;
				var result = this.resultFormatter &amp;&amp; this.resultFormatter(this);
				if (result instanceof Function) {
					result.call(this,
							createjs.proxy(this._resultFormatSuccess, this),
							createjs.proxy(this._resultFormatFailed, this)
					);
				} else {
					this._result =  result || this._rawResult;
					this._sendComplete();
				}
				break;
			case &quot;progress&quot;:
				this._sendProgress(event);
				break;
			case &quot;error&quot;:
				this._sendError(event);
				break;
			case &quot;loadstart&quot;:
				this._sendLoadStart();
				break;
			case &quot;abort&quot;:
			case &quot;timeout&quot;:
				if (!this._isCanceled()) {
					this.dispatchEvent(new createjs.ErrorEvent(&quot;PRELOAD_&quot; + event.type.toUpperCase() + &quot;_ERROR&quot;));
				}
				break;
		}
	};

	/**
	 * The &quot;success&quot; callback passed to {{#crossLink &quot;AbstractLoader/resultFormatter&quot;}}{{/crossLink}} asynchronous
	 * functions.
	 * @method _resultFormatSuccess
	 * @param {Object} result The formatted result
	 * @private
	 */
	p._resultFormatSuccess = function (result) {
		this._result = result;
		this._sendComplete();
	};

	/**
	 * The &quot;error&quot; callback passed to {{#crossLink &quot;AbstractLoader/resultFormatter&quot;}}{{/crossLink}} asynchronous
	 * functions.
	 * @method _resultFormatSuccess
	 * @param {Object} error The error event
	 * @private
	 */
	p._resultFormatFailed = function (event) {
		this._sendError(event);
	};

	/**
	 * @method buildPath
	 * @protected
	 * @deprecated Use the {{#crossLink &quot;RequestUtils&quot;}}{{/crossLink}} method {{#crossLink &quot;RequestUtils/buildPath&quot;}}{{/crossLink}}
	 * instead.
	 */
	p.buildPath = function (src, data) {
		return createjs.RequestUtils.buildPath(src, data);
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function () {
		return &quot;[PreloadJS AbstractLoader]&quot;;
	};

	createjs.AbstractLoader = createjs.promote(AbstractLoader, &quot;EventDispatcher&quot;);

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
	 * handle HTML media elements, such as Video and Audio.
	 * @class AbstractMediaLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @param {String} type The type of media to load. Usually &quot;video&quot; or &quot;audio&quot;.
	 * @extends AbstractLoader
	 * @constructor
	 */
	function AbstractMediaLoader(loadItem, preferXHR, type) {
		this.AbstractLoader_constructor(loadItem, preferXHR, type);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = &quot;src&quot;;

        this.on(&quot;initialize&quot;, this._updateXHR, this);
	};

	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

	// static properties
	// public methods
	p.load = function () {
		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
		if (!this._tag) {
			this._tag = this._createTag(this._item.src);
		}

		this._tag.preload = &quot;auto&quot;;
		this._tag.load();

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Creates a new tag for loading if it doesn&#x27;t exist yet.
	 * @method _createTag
	 * @private
	 */
	p._createTag = function () {};


	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

    // protected methods
    /**
     * Before the item loads, set its mimeType and responseType.
     * @property _updateXHR
     * @param {Event} event
     * @private
     */
    p._updateXHR = function (event) {
        // Only exists for XHR
        if (event.loader.setResponseType) {
            event.loader.setResponseType(&quot;blob&quot;);
        }
    };

	/**
	 * The result formatter for media files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLVideoElement|HTMLAudioElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		this._tag.removeEventListener &amp;&amp; this._tag.removeEventListener(&quot;canplaythrough&quot;, this._loadedHandler);
		this._tag.onstalled = null;
		if (this._preferXHR) {
            var URL = window.URL || window.webkitURL;
            var result = loader.getResult(true);

			loader.getTag().src = URL.createObjectURL(result);
		}
		return loader.getTag();
	};

	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	/**
	 * A base class for actual data requests, such as {{#crossLink &quot;XHRRequest&quot;}}{{/crossLink}}, {{#crossLink &quot;TagRequest&quot;}}{{/crossLink}},
	 * and {{#crossLink &quot;MediaRequest&quot;}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
	 * hood to get data.
	 * @class AbstractRequest
	 * @param {LoadItem} item
	 * @constructor
	 */
	var AbstractRequest = function (item) {
		this._item = item;
	};

	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

	// public methods
	/**
	 * Begin a load.
	 * @method load
	 */
	p.load =  function() {};

	/**
	 * Clean up a request.
	 * @method destroy
	 */
	p.destroy = function() {};

	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	p.cancel = function() {};

	createjs.AbstractRequest = createjs.promote(AbstractRequest, &quot;EventDispatcher&quot;);

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * An {{#crossLink &quot;AbstractRequest&quot;}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as &quot;src&quot;, &quot;href&quot;, etc.
	 */
	function TagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		/**
		 * The HTML tag instance that is used to load.
		 * @property _tag
		 * @type {HTMLElement}
		 * @protected
		 */
		this._tag = tag;

		/**
		 * The tag attribute that specifies the source, such as &quot;src&quot;, &quot;href&quot;, etc.
		 * @property _tagSrcAttribute
		 * @type {String}
		 * @protected
		 */
		this._tagSrcAttribute = srcAttribute;

		/**
		 * A method closure used for handling the tag load event.
		 * @property _loadedHandler
		 * @type {Function}
		 * @private
		 */
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

		/**
		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
		 * @property _addedToDOM
		 * @type {Boolean}
		 * @private
		 */
		this._addedToDOM = false;

		/**
		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.
		 *
		 * @type {null}
		 * @private
		 */
		this._startTagVisibility = null;
	};

	var p = createjs.extend(TagRequest, createjs.AbstractRequest);

	// public methods
	p.load = function () {
		this._tag.onload = createjs.proxy(this._handleTagComplete, this);
		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
		this._tag.onerror = createjs.proxy(this._handleError, this);

		var evt = new createjs.Event(&quot;initialize&quot;);
		evt.loader = this._tag;

		this.dispatchEvent(evt);

		this._hideTag();

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		this._tag[this._tagSrcAttribute] = this._item.src;

		// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
		if (this._tag.parentNode == null) {
			window.document.body.appendChild(this._tag);
			this._addedToDOM = true;
		}
	};

	p.destroy = function() {
		this._clean();
		this._tag = null;

		this.AbstractRequest_destroy();
	};

	// private methods
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the &#x60;onload&#x60; callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == &quot;loaded&quot; || tag.readyState == &quot;complete&quot;) {
			this._handleTagComplete();
		}
	};

	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	p._handleError = function() {
		this._clean();
		this.dispatchEvent(&quot;error&quot;);
	};

	/**
	 * Handle the tag&#x27;s onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	p._handleTagComplete = function () {
		this._rawResult = this._tag;
		this._result = this.resultFormatter &amp;&amp; this.resultFormatter(this) || this._rawResult;

		this._clean();
		this._showTag();

		this.dispatchEvent(&quot;complete&quot;);
	};

	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._clean();
		this.dispatchEvent(new createjs.Event(&quot;timeout&quot;));
	};

	/**
	 * Remove event listeners, but don&#x27;t destroy the request object
	 * @method _clean
	 * @private
	 */
	p._clean = function() {
		this._tag.onload = null;
		this._tag.onreadystatechange = null;
		this._tag.onerror = null;
		if (this._addedToDOM &amp;&amp; this._tag.parentNode != null) {
			this._tag.parentNode.removeChild(this._tag);
		}
		clearTimeout(this._loadTimeout);
	};

	p._hideTag = function() {
		this._startTagVisibility = this._tag.style.visibility;
		this._tag.style.visibility = &quot;hidden&quot;;
	};

	p._showTag = function() {
		this._tag.style.visibility = this._startTagVisibility;
	};

	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	createjs.TagRequest = createjs.promote(TagRequest, &quot;AbstractRequest&quot;);

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * An {{#crossLink &quot;TagRequest&quot;}}{{/crossLink}} that loads HTML tags for video and audio.
	 * @class MediaTagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLAudioElement|HTMLVideoElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as &quot;src&quot;, &quot;href&quot;, etc.
	 * @constructor
	 */
	function MediaTagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		this._tag = tag;
		this._tagSrcAttribute = srcAttribute;
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
	};

	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
	var s = MediaTagRequest;

	// public methods
	p.load = function () {
		var sc = createjs.proxy(this._handleStalled, this);
		this._stalledCallback = sc;

		var pc = createjs.proxy(this._handleProgress, this);
		this._handleProgress = pc;

		this._tag.addEventListener(&quot;stalled&quot;, sc);
		this._tag.addEventListener(&quot;progress&quot;, pc);

		// This will tell us when audio is buffered enough to play through, but not when its loaded.
		// The tag doesn&#x27;t keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
		this._tag.addEventListener &amp;&amp; this._tag.addEventListener(&quot;canplaythrough&quot;, this._loadedHandler, false); // canplaythrough callback doesn&#x27;t work in Chrome, so we use an event.

		this.TagRequest_load();
	};

	// private methods
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == &quot;loaded&quot; || tag.readyState == &quot;complete&quot;) {
			this._handleTagComplete();
		}
	};

	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	/**
	 * An XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded &gt; 0 &amp;&amp; event.total == 0) {
			return; // Sometimes we get no &quot;total&quot;, so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	// protected methods
	p._clean = function () {
		this._tag.removeEventListener &amp;&amp; this._tag.removeEventListener(&quot;canplaythrough&quot;, this._loadedHandler);
		this._tag.removeEventListener(&quot;stalled&quot;, this._stalledCallback);
		this._tag.removeEventListener(&quot;progress&quot;, this._progressCallback);

		this.TagRequest__clean();
	};

	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, &quot;TagRequest&quot;);

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

// constructor
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	function XHRRequest (item) {
		this.AbstractRequest_constructor(item);

		// protected properties
		/**
		 * A reference to the XHR request used to load the content.
		 * @property _request
		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
		 * @private
		 */
		this._request = null;

		/**
		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
		 * typically IE9).
		 * @property _loadTimeout
		 * @type {Number}
		 * @private
		 */
		this._loadTimeout = null;

		/**
		 * The browser&#x27;s XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
		 * the version, so we use capabilities to make a best guess.
		 * @property _xhrLevel
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._xhrLevel = 1;

		/**
		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		 * null until the file is loaded.
		 * @property _response
		 * @type {mixed}
		 * @private
		 */
		this._response = null;

		/**
		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
		 * an HTML tag or a formatted object which is set to the &lt;code&gt;result&lt;/code&gt; property, but the developer may still
		 * want to access the raw content as it was loaded.
		 * @property _rawResponse
		 * @type {String|Object}
		 * @private
		 */
		this._rawResponse = null;

		this._canceled = false;

		// Setup our event handlers now.
		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
		this._handleErrorProxy = createjs.proxy(this._handleError, this);
		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

		if (!this._createXHR(item)) {
			//TODO: Throw error?
		}
	};

	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	XHRRequest.ACTIVEX_VERSIONS = [
		&quot;Msxml2.XMLHTTP.6.0&quot;,
		&quot;Msxml2.XMLHTTP.5.0&quot;,
		&quot;Msxml2.XMLHTTP.4.0&quot;,
		&quot;MSXML2.XMLHTTP.3.0&quot;,
		&quot;MSXML2.XMLHTTP&quot;,
		&quot;Microsoft.XMLHTTP&quot;
	];

// Public methods
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * &lt;ul&gt;
	 *      &lt;li&gt;An image tag (&amp;lt;image /&amp;gt;) for images&lt;/li&gt;
	 *      &lt;li&gt;A script tag for JavaScript (&amp;lt;script /&amp;gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.&lt;/li&gt;
	 *      &lt;li&gt;A style tag for CSS (&amp;lt;style /&amp;gt;)&lt;/li&gt;
	 *      &lt;li&gt;Raw text for TEXT&lt;/li&gt;
	 *      &lt;li&gt;A formatted JavaScript object defined by JSON&lt;/li&gt;
	 *      &lt;li&gt;An XML document&lt;/li&gt;
	 *      &lt;li&gt;An binary arraybuffer loaded by XHR&lt;/li&gt;
	 * &lt;/ul&gt;
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (raw) {
		if (raw &amp;&amp; this._rawResponse) {
			return this._rawResponse;
		}
		return this._response;
	};

	// Overrides abstract method in AbstractRequest
	p.cancel = function () {
		this.canceled = true;
		this._clean();
		this._request.abort();
	};

	// Overrides abstract method in AbstractLoader
	p.load = function () {
		if (this._request == null) {
			this._handleError();
			return;
		}

		//Events
		if (this._request.addEventListener != null) {
			this._request.addEventListener(&quot;loadstart&quot;, this._handleLoadStartProxy, false);
			this._request.addEventListener(&quot;progress&quot;, this._handleProgressProxy, false);
			this._request.addEventListener(&quot;abort&quot;, this._handleAbortProxy, false);
			this._request.addEventListener(&quot;error&quot;, this._handleErrorProxy, false);
			this._request.addEventListener(&quot;timeout&quot;, this._handleTimeoutProxy, false);

			// Note: We don&#x27;t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.addEventListener(&quot;load&quot;, this._handleLoadProxy, false);
			this._request.addEventListener(&quot;readystatechange&quot;, this._handleReadyStateChangeProxy, false);
		} else {
			// IE9 support
			this._request.onloadstart = this._handleLoadStartProxy;
			this._request.onprogress = this._handleProgressProxy;
			this._request.onabort = this._handleAbortProxy;
			this._request.onerror = this._handleErrorProxy;
			this._request.ontimeout = this._handleTimeoutProxy;

			// Note: We don&#x27;t get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.onload = this._handleLoadProxy;
			this._request.onreadystatechange = this._handleReadyStateChangeProxy;
		}

		// Set up a timeout if we don&#x27;t have XHR2
		if (this._xhrLevel == 1) {
			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
		}

		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
		try {
			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
				this._request.send();
			} else if (this._item.method == createjs.AbstractLoader.POST) {
				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
			}
		} catch (error) {
			this.dispatchEvent(new createjs.ErrorEvent(&quot;XHR_SEND&quot;, null, error));
		}
	};

	p.setResponseType = function (type) {
		// Some old browsers doesn&#x27;t support blob, so we convert arraybuffer to blob after response is downloaded
		if (type === &#x27;blob&#x27;) {
			type = window.URL ? &#x27;blob&#x27; : &#x27;arraybuffer&#x27;;
			this._responseType = type;
		}
		this._request.responseType = type;
	};

	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * &lt;strong&gt;From the docs:&lt;/strong&gt; Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getAllResponseHeaders = function () {
		if (this._request.getAllResponseHeaders instanceof Function) {
			return this._request.getAllResponseHeaders();
		} else {
			return null;
		}
	};

	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * &lt;strong&gt;From the docs:&lt;/strong&gt; Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getResponseHeader = function (header) {
		if (this._request.getResponseHeader instanceof Function) {
			return this._request.getResponseHeader(header);
		} else {
			return null;
		}
	};

// protected methods
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded &gt; 0 &amp;&amp; event.total == 0) {
			return; // Sometimes we get no &quot;total&quot;, so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	p._handleLoadStart = function (event) {
		clearTimeout(this._loadTimeout);
		this.dispatchEvent(&quot;loadstart&quot;);
	};

	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	p._handleAbort = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(&quot;XHR_ABORTED&quot;, null, event));
	};

	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleError = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(event.message));
	};

	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 &amp; 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	p._handleReadyStateChange = function (event) {
		if (this._request.readyState == 4) {
			this._handleLoad();
		}
	};

	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * &lt;code&gt;request.readyState == 4&lt;/code&gt;. Only the first call to this method will be processed.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	p._handleLoad = function (event) {
		if (this.loaded) {
			return;
		}
		this.loaded = true;

		var error = this._checkError();
		if (error) {
			this._handleError(error);
			return;
		}

		this._response = this._getResponse();
		// Convert arraybuffer back to blob
		if (this._responseType === &#x27;arraybuffer&#x27;) {
			try {
				this._response = new Blob([this._response]);
			} catch (e) {
				// Fallback to use BlobBuilder if Blob constructor is not supported
				// Tested on Android 2.3 ~ 4.2 and iOS5 safari
				window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				if (e.name === &#x27;TypeError&#x27; &amp;&amp; window.BlobBuilder) {
					var builder = new BlobBuilder();
					builder.append(this._response);
					this._response = builder.getBlob();
				}
			}
		}
		this._clean();

		this.dispatchEvent(new createjs.Event(&quot;complete&quot;));
	};

	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a &lt;code&gt;setTimeout&lt;/code&gt;
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	p._handleTimeout = function (event) {
		this._clean();

		this.dispatchEvent(new createjs.ErrorEvent(&quot;PRELOAD_TIMEOUT&quot;, null, event));
	};

// Protected
	/**
	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note
	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.
	 * @method _checkError
	 * @return {int} If the request status returns an error code.
	 * @private
	 */
	p._checkError = function () {
		//LM: Probably need additional handlers here, maybe 501
		var status = parseInt(this._request.status);

		switch (status) {
			case 404:   // Not Found
			case 0:     // Not Loaded
				return new Error(status);
		}
		return null;
	};

	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the &lt;code&gt;_response&lt;/code&gt; property will remain null.
	 * @method _getResponse
	 * @private
	 */
	p._getResponse = function () {
		if (this._response != null) {
			return this._response;
		}

		if (this._request.response != null) {
			return this._request.response;
		}

		// Android 2.2 uses .responseText
		try {
			if (this._request.responseText != null) {
				return this._request.responseText;
			}
		} catch (e) {
		}

		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml
		try {
			if (this._request.responseXML != null) {
				return this._request.responseXML;
			}
		} catch (e) {
		}

		return null;
	};

	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * &lt;ol&gt;&lt;li&gt;Some browsers get an &lt;code&gt;XDomainRequest&lt;/code&gt; when loading cross-domain.&lt;/li&gt;
	 *      &lt;li&gt;XMLHttpRequest are created when available.&lt;/li&gt;
	 *      &lt;li&gt;ActiveX.XMLHTTP objects are used in older IE browsers.&lt;/li&gt;
	 *      &lt;li&gt;Text requests override the mime type if possible&lt;/li&gt;
	 *      &lt;li&gt;Origin headers are sent for crossdomain requests in some browsers.&lt;/li&gt;
	 *      &lt;li&gt;Binary loads set the response type to &quot;arraybuffer&quot;&lt;/li&gt;&lt;/ol&gt;
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	p._createXHR = function (item) {
		// Check for cross-domain loads. We can&#x27;t fully support them, but we can try.
		var crossdomain = createjs.RequestUtils.isCrossDomain(item);
		var headers = {};

		// Create the request. Fallback to whatever support we have.
		var req = null;
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			// This is 8 or 9, so use XDomainRequest instead.
			if (crossdomain &amp;&amp; req.withCredentials === undefined &amp;&amp; window.XDomainRequest) {
				req = new XDomainRequest();
			}
		} else { // Old IE versions use a different approach
			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i &lt; l; i++) {
				var axVersion = s.ACTIVEX_VERSIONS[i];
				try {
					req = new ActiveXObject(axVersion);
					break;
				} catch (e) {
				}
			}
			if (req == null) {
				return false;
			}
		}

		// Default to utf-8 for Text requests.
		if (item.mimeType == null &amp;&amp; createjs.RequestUtils.isText(item.type)) {
			item.mimeType = &quot;text/plain; charset=utf-8&quot;;
		}

		// IE9 doesn&#x27;t support overrideMimeType(), so we need to check for it.
		if (item.mimeType &amp;&amp; req.overrideMimeType) {
			req.overrideMimeType(item.mimeType);
		}

		// Determine the XHR level
		this._xhrLevel = (typeof req.responseType === &quot;string&quot;) ? 2 : 1;

		var src = null;
		if (item.method == createjs.AbstractLoader.GET) {
			src = createjs.RequestUtils.buildPath(item.src, item.values);
		} else {
			src = item.src;
		}

		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
		req.open(item.method || createjs.AbstractLoader.GET, src, true);

		if (crossdomain &amp;&amp; req instanceof XMLHttpRequest &amp;&amp; this._xhrLevel == 1) {
			headers[&quot;Origin&quot;] = location.origin;
		}

		// To send data we need to set the Content-type header)
		if (item.values &amp;&amp; item.method == createjs.AbstractLoader.POST) {
			headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;;
		}

		if (!crossdomain &amp;&amp; !headers[&quot;X-Requested-With&quot;]) {
			headers[&quot;X-Requested-With&quot;] = &quot;XMLHttpRequest&quot;;
		}

		if (item.headers) {
			for (var n in item.headers) {
				headers[n] = item.headers[n];
			}
		}

		for (n in headers) {
			req.setRequestHeader(n, headers[n])
		}

		if (req instanceof XMLHttpRequest &amp;&amp; item.withCredentials !== undefined) {
			req.withCredentials = item.withCredentials;
		}

		this._request = req;

		return true;
	};

	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	p._clean = function () {
		clearTimeout(this._loadTimeout);

		if (this._request.removeEventListener != null) {
			this._request.removeEventListener(&quot;loadstart&quot;, this._handleLoadStartProxy);
			this._request.removeEventListener(&quot;progress&quot;, this._handleProgressProxy);
			this._request.removeEventListener(&quot;abort&quot;, this._handleAbortProxy);
			this._request.removeEventListener(&quot;error&quot;, this._handleErrorProxy);
			this._request.removeEventListener(&quot;timeout&quot;, this._handleTimeoutProxy);
			this._request.removeEventListener(&quot;load&quot;, this._handleLoadProxy);
			this._request.removeEventListener(&quot;readystatechange&quot;, this._handleReadyStateChangeProxy);
		} else {
			this._request.onloadstart = null;
			this._request.onprogress = null;
			this._request.onabort = null;
			this._request.onerror = null;
			this._request.ontimeout = null;
			this._request.onload = null;
			this._request.onreadystatechange = null;
		}
	};

	p.toString = function () {
		return &quot;[PreloadJS XHRRequest]&quot;;
	};

	createjs.XHRRequest = createjs.promote(XHRRequest, &quot;AbstractRequest&quot;);

}());

//##############################################################################
// LoadQueue.js
//##############################################################################

this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
	&quot;use strict&quot;;

// constructor
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * &lt;b&gt;Creating a Queue&lt;/b&gt;&lt;br /&gt;
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * &lt;b&gt;Listening for Events&lt;/b&gt;&lt;br /&gt;
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink &quot;EventDispatcher&quot;}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:&lt;ul&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/complete:event&quot;}}{{/crossLink}}: fired when a queue completes loading all
	 *     files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/error:event&quot;}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/progress:event&quot;}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}: A single file has completed loading.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;LoadQueue/fileprogress:event&quot;}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 *      queue.on(&quot;fileload&quot;, handleFileLoad, this);
	 *      queue.on(&quot;complete&quot;, handleComplete, this);
	 *
	 * &lt;b&gt;Adding files and manifests&lt;/b&gt;&lt;br /&gt;
	 * Add files you want to load using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile(&quot;filePath/file.jpg&quot;);
	 *      queue.loadFile({id:&quot;image&quot;, src:&quot;filePath/file.jpg&quot;});
	 *      queue.loadManifest([&quot;filePath/file.jpg&quot;, {id:&quot;image&quot;, src:&quot;filePath/file.jpg&quot;}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest(&quot;path/to/manifest.json&quot;);
	 *      queue.loadManifest({src:&quot;manifest.json&quot;, type:&quot;manifest&quot;});
	 *
	 * If you pass &#x60;false&#x60; as the &#x60;loadNow&#x60; parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink &quot;AbstractLoader/load&quot;}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * &#x60;loadNow&#x60; argument of &#x60;true&#x60;.
	 *
	 *      queue.load();
	 *
	 * &lt;b&gt;File Types&lt;/b&gt;&lt;br /&gt;
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * &lt;code&gt;type&lt;/code&gt; property with any manifest item.
	 *
	 *      queue.loadFile({src:&quot;path/to/myFile.mp3x&quot;, type:createjs.AbstractLoader.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:&quot;http://server.com/proxy?file=image.jpg&quot;, type:createjs.AbstractLoader.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}} class, and include:
	 * &lt;ul&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/BINARY:property&quot;}}{{/crossLink}}: Raw binary data via XHR&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/CSS:property&quot;}}{{/crossLink}}: CSS files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/IMAGE:property&quot;}}{{/crossLink}}: Common image formats&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/JAVASCRIPT:property&quot;}}{{/crossLink}}: JavaScript files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/JSON:property&quot;}}{{/crossLink}}: JSON data&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/JSONP:property&quot;}}{{/crossLink}}: JSON files cross-domain&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/MANIFEST:property&quot;}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink &quot;AbstractLoader/loadManifest&quot;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/SOUND:property&quot;}}{{/crossLink}}: Audio file formats&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/SPRITESHEET:property&quot;}}{{/crossLink}}: JSON SpriteSheet definitions. This
	 *     will also load sub-images, and provide a {{#crossLink &quot;SpriteSheet&quot;}}{{/crossLink}} instance.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/SVG:property&quot;}}{{/crossLink}}: SVG files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/TEXT:property&quot;}}{{/crossLink}}: Text files - XHR only&lt;/li&gt;
     *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/VIDEO:property&quot;}}{{/crossLink}}: Video objects&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &quot;AbstractLoader/XML:property&quot;}}{{/crossLink}}: XML data&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;em&gt;Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better
	 * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but
	 * are deprecated.&lt;/em&gt;
	 *
	 * &lt;b&gt;Handling Results&lt;/b&gt;&lt;br /&gt;
	 * When a file is finished downloading, a {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * &lt;ul&gt;
	 *     &lt;li&gt;Binary: The binary loaded result&lt;/li&gt;
	 *     &lt;li&gt;CSS: A &amp;lt;link /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;Image: An &amp;lt;img /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;JavaScript: A &amp;lt;script /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;JSON/JSONP: A formatted JavaScript Object&lt;/li&gt;
	 *     &lt;li&gt;Manifest: A JavaScript object.
	 *     &lt;li&gt;Sound: An &amp;lt;audio /&amp;gt; tag&lt;/a&gt;
	 *     &lt;li&gt;SpriteSheet: A {{#crossLink &quot;SpriteSheet&quot;}}{{/crossLink}} instance, containing loaded images.
	 *     &lt;li&gt;SVG: An &amp;lt;object /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;Text: Raw text&lt;/li&gt;
     *     &lt;li&gt;Video: A Video DOM node&lt;/li&gt;
	 *     &lt;li&gt;XML: An XML DOM node&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.LoadQueue.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its &quot;id&quot; using {{#crossLink &quot;LoadQueue/getResult&quot;}}{{/crossLink}}. If no id was provided, then the
	 * &quot;src&quot; or file path can be used instead, including the &#x60;path&#x60; defined by a manifest, but &lt;strong&gt;not including&lt;/strong&gt;
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult(&quot;image&quot;);
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the &lt;code&gt;rawResult&lt;/code&gt; property of the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink &quot;LoadQueue/getResult&quot;}}{{/crossLink}}, passing &#x60;true&#x60; as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult(&quot;image&quot;, true); // load the binary image data loaded with XHR.
	 *
	 * &lt;b&gt;Plugins&lt;/b&gt;&lt;br /&gt;
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the &lt;a href=&quot;http://soundjs.com&quot;&gt;SoundJS&lt;/a&gt; Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed &lt;strong&gt;before&lt;/strong&gt; loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * &lt;h4&gt;Known Browser Issues&lt;/h4&gt;
	 * &lt;ul&gt;
	 *     &lt;li&gt;Browsers without audio support can not load audio files.&lt;/li&gt;
	 *     &lt;li&gt;Safari on Mac OS X can only play HTML audio if QuickTime is installed&lt;/li&gt;
	 *     &lt;li&gt;HTML Audio tags will only download until their &lt;code&gt;canPlayThrough&lt;/code&gt; event is fired. Browsers other
	 *     than Chrome will continue to download in the background.&lt;/li&gt;
	 *     &lt;li&gt;When loading scripts using tags, they are automatically added to the document.&lt;/li&gt;
	 *     &lt;li&gt;Scripts loaded via XHR may not be properly inspectable with browser tools.&lt;/li&gt;
	 *     &lt;li&gt;IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.&lt;/li&gt;
	 *     &lt;li&gt;Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is &#x60;false&#x60;, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=&quot;&quot;] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as &#x60;http://&#x60; or a relative path such as &#x60;../&#x60;
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=&quot;&quot;] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to &#x60;true&#x60;, which will default the crossOrigin property on images to &quot;Anonymous&quot;. Any
	 * string value will be passed through, but only &quot;&quot; and &quot;Anonymous&quot; are recommended. &lt;strong&gt;Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead&lt;/strong&gt;
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	function LoadQueue (preferXHR, basePath, crossOrigin) {
		this.AbstractLoader_constructor();

		/**
		 * An array of the plugins registered using {{#crossLink &quot;LoadQueue/installPlugin&quot;}}{{/crossLink}}.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this._plugins = [];

		/**
		 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink &quot;LoadQueue/installPlugin&quot;}}{{/crossLink}}
		 * method for more information.
		 * @property _typeCallbacks
		 * @type {Object}
		 * @private
		 */
		this._typeCallbacks = {};

		/**
		 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink &quot;LoadQueue/installPlugin&quot;}}{{/crossLink}}
		 * method for more information.
		 * @property _extensionCallbacks
		 * @type {null}
		 * @private
		 */
		this._extensionCallbacks = {};

		/**
		 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
		 * {{#crossLink &quot;LoadQueue/stopOnError:property&quot;}}{{/crossLink}} is &#x60;true&#x60;, the next queue will not be processed.
		 * @property next
		 * @type {LoadQueue}
		 * @default null
		 */
		this.next = null;

		/**
		 * Ensure loaded scripts &quot;complete&quot; in the order they are specified. Loaded scripts are added to the document head
		 * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is &#x60;true&#x60;, whereas
		 * scripts loaded using XHR can load in any order, but will &quot;finish&quot; and be added to the document in the order
		 * specified.
		 *
		 * Any items can be set to load in order by setting the {{#crossLink &quot;maintainOrder:property&quot;}}{{/crossLink}}
		 * property on the load item, or by ensuring that only one connection can be open at a time using
		 * {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}}. Note that when the &#x60;maintainScriptOrder&#x60; property
		 * is set to &#x60;true&#x60;, scripts items are automatically set to &#x60;maintainOrder=true&#x60;, and changing the
		 * &#x60;maintainScriptOrder&#x60; to &#x60;false&#x60; during a load will not change items already in a queue.
		 *
		 * &lt;h4&gt;Example&lt;/h4&gt;
		 *
		 *      var queue = new createjs.LoadQueue();
		 *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
		 *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
		 *      queue.loadManifest([
		 *          &quot;script1.js&quot;,
		 *          &quot;script2.js&quot;,
		 *          &quot;image.png&quot;, // Load any time
		 *          {src: &quot;image2.png&quot;, maintainOrder: true} // Will wait for script2.js
		 *          &quot;image3.png&quot;,
		 *          &quot;script3.js&quot; // Will wait for image2.png before loading (or completing when loading with XHR)
		 *      ]);
		 *
		 * @property maintainScriptOrder
		 * @type {Boolean}
		 * @default true
		 */
		this.maintainScriptOrder = true;

		/**
		 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
		 * @property stopOnError
		 * @type {Boolean}
		 * @default false
		 */
		this.stopOnError = false;

		/**
		 * The number of maximum open connections that a loadQueue tries to maintain. Please see
		 * {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}} for more information.
		 * @property _maxConnections
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._maxConnections = 1;

		/**
		 * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
		 * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
		 * handle the content, it will be selected. The default loader, ({{#crossLink &quot;TextLoader&quot;}}{{/crossLink}} is
		 * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
		 * {{#crossLink &quot;LoadItem/type&quot;}}{{/crossLink}}, which is automatically determined using the file extension of
		 * the {{#crossLink &quot;LoadItem/src:property&quot;}}{{/crossLink}}.
		 *
		 * Loaders can be removed from PreloadJS by simply not including them.
		 *
		 * Custom loaders installed using {{#crossLink &quot;registerLoader&quot;}}{{/crossLink}} will be prepended to this list
		 * so that they are checked first.
		 * @property _availableLoaders
		 * @type {Array}
		 * @private
		 * @since 0.6.0
		 */
		this._availableLoaders = [
			createjs.ImageLoader,
			createjs.JavaScriptLoader,
			createjs.CSSLoader,
			createjs.JSONLoader,
			createjs.JSONPLoader,
			createjs.SoundLoader,
			createjs.ManifestLoader,
			createjs.SpriteSheetLoader,
			createjs.XMLLoader,
			createjs.SVGLoader,
			createjs.BinaryLoader,
			createjs.VideoLoader,
			createjs.TextLoader
		];

		/**
		 * The number of built in loaders, so they can&#x27;t be removed by {{#crossLink &quot;unregisterLoader&quot;}}{{/crossLink}.
				 * @property _defaultLoaderLength
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._defaultLoaderLength = this._availableLoaders.length;

		this.init(preferXHR, basePath, crossOrigin);
	}

	var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
	var s = LoadQueue;

	/**
	 * &lt;strong&gt;REMOVED&lt;/strong&gt;. Removed in favor of using &#x60;MySuperClass_constructor&#x60;.
	 * See {{#crossLink &quot;Utility Methods/extend&quot;}}{{/crossLink}} and {{#crossLink &quot;Utility Methods/promote&quot;}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	p.init = function (preferXHR, basePath, crossOrigin) {

		// public properties
		/**
		 * @property useXHR
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 * @deprecated Use preferXHR instead.
		 */
		this.useXHR = true;

		/**
		 * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
		 * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
		 * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
		 * user-defined type.
		 * @type {Boolean}
		 * @default true
		 * @since 0.6.0
		 */
		this.preferXHR = true; //TODO: Get/Set
		this._preferXHR = true;
		this.setPreferXHR(preferXHR);

		// protected properties
		/**
		 * Whether the queue is currently paused or not.
		 * @property _paused
		 * @type {boolean}
		 * @private
		 */
		this._paused = false;

		/**
		 * A path that will be prepended on to the item&#x27;s {{#crossLink &quot;LoadItem/src:property&quot;}}{{/crossLink}}. The
		 * &#x60;_basePath&#x60; property will only be used if an item&#x27;s source is relative, and does not include a protocol such
		 * as &#x60;http://&#x60;, or a relative path such as &#x60;../&#x60;.
		 * @property _basePath
		 * @type {String}
		 * @private
		 * @since 0.3.1
		 */
		this._basePath = basePath;

		/**
		 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
		 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
		 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
		 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are &quot;&quot;
		 * and &quot;Anonymous&quot;.
		 * @property _crossOrigin
		 * @type {String}
		 * @default &quot;&quot;
		 * @private
		 * @since 0.4.1
		 */
		this._crossOrigin = crossOrigin;

		/**
		 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
		 * file is requested.
		 * @property _loadStartWasDispatched
		 * @type {Boolean}
		 * @default false
		 * @private
		 */
		this._loadStartWasDispatched = false;

		/**
		 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
		 * using a script tag to do preloading.
		 * @property _currentlyLoadingScript
		 * @type {Boolean}
		 * @private
		 */
		this._currentlyLoadingScript = null;

		/**
		 * An array containing the currently downloading files.
		 * @property _currentLoads
		 * @type {Array}
		 * @private
		 */
		this._currentLoads = [];

		/**
		 * An array containing the queued items that have not yet started downloading.
		 * @property _loadQueue
		 * @type {Array}
		 * @private
		 */
		this._loadQueue = [];

		/**
		 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
		 * @property _loadQueueBackup
		 * @type {Array}
		 * @private
		 */
		this._loadQueueBackup = [];

		/**
		 * An object hash of items that have finished downloading, indexed by the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}
		 * id.
		 * @property _loadItemsById
		 * @type {Object}
		 * @private
		 */
		this._loadItemsById = {};

		/**
		 * An object hash of items that have finished downloading, indexed by {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}
		 * source.
		 * @property _loadItemsBySrc
		 * @type {Object}
		 * @private
		 */
		this._loadItemsBySrc = {};

		/**
		 * An object hash of loaded items, indexed by the ID of the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}.
		 * @property _loadedResults
		 * @type {Object}
		 * @private
		 */
		this._loadedResults = {};

		/**
		 * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}.
		 * @property _loadedRawResults
		 * @type {Object}
		 * @private
		 */
		this._loadedRawResults = {};

		/**
		 * The number of items that have been requested. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded. This does not include items inside of loaders such as the
		 * {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}.
		 * @property _numItems
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItems = 0;

		/**
		 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded.
		 * @property _numItemsLoaded
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItemsLoaded = 0;

		/**
		 * A list of scripts in the order they were requested. This helps ensure that scripts are &quot;completed&quot; in the right
		 * order.
		 * @property _scriptOrder
		 * @type {Array}
		 * @private
		 */
		this._scriptOrder = [];

		/**
		 * A list of scripts that have been loaded. Items are added to this list as &lt;code&gt;null&lt;/code&gt; when they are
		 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and &lt;code&gt;true&lt;/true&gt;
		 * once they are complete and have been dispatched.
		 * @property _loadedScripts
		 * @type {Array}
		 * @private
		 */
		this._loadedScripts = [];

		/**
		 * The last progress amount. This is used to suppress duplicate progress events.
		 * @property _lastProgress
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._lastProgress = NaN;

	};

// static properties
	/**
	 * The time in milliseconds to assume a load has failed. An {{#crossLink &quot;AbstractLoader/error:event&quot;}}{{/crossLink}}
	 * event is dispatched if the timeout is reached before any data is received.
	 * @property loadTimeout
	 * @type {Number}
	 * @default 8000
	 * @static
	 * @since 0.4.1
	 * @deprecated In favour of {{#crossLink &quot;LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.
	 */
	s.loadTimeout = 8000;

	/**
	 * The time in milliseconds to assume a load has failed.
	 * @property LOAD_TIMEOUT
	 * @type {Number}
	 * @default 0
	 * @deprecated in favor of the {{#crossLink &quot;LoadQueue/loadTimeout:property&quot;}}{{/crossLink}} property.
	 */
	s.LOAD_TIMEOUT = 0;

// Preload Types
	/**
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/BINARY:property&quot;}}{{/crossLink}} instead.
	 */
	s.BINARY = createjs.AbstractLoader.BINARY;

	/**
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/CSS:property&quot;}}{{/crossLink}} instead.
	 */
	s.CSS = createjs.AbstractLoader.CSS;

	/**
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/CSS:property&quot;}}{{/crossLink}} instead.
	 */
	s.IMAGE = createjs.AbstractLoader.IMAGE;

	/**
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/JAVASCRIPT:property&quot;}}{{/crossLink}} instead.
	 */
	s.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;

	/**
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/JSON:property&quot;}}{{/crossLink}} instead.
	 */
	s.JSON = createjs.AbstractLoader.JSON;

	/**
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/JSONP:property&quot;}}{{/crossLink}} instead.
	 */
	s.JSONP = createjs.AbstractLoader.JSONP;

	/**
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.4.1
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/MANIFEST:property&quot;}}{{/crossLink}} instead.
	 */
	s.MANIFEST = createjs.AbstractLoader.MANIFEST;

	/**
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/JAVASCRIPT:property&quot;}}{{/crossLink}} instead.
	 */
	s.SOUND = createjs.AbstractLoader.SOUND;

	/**
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/JAVASCRIPT:property&quot;}}{{/crossLink}} instead.
	 */
	s.VIDEO = createjs.AbstractLoader.VIDEO;

	/**
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/SVG:property&quot;}}{{/crossLink}} instead.
	 */
	s.SVG = createjs.AbstractLoader.SVG;

	/**
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/TEXT:property&quot;}}{{/crossLink}} instead.
	 */
	s.TEXT = createjs.AbstractLoader.TEXT;

	/**
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/XML:property&quot;}}{{/crossLink}} instead.
	 */
	s.XML = createjs.AbstractLoader.XML;

	/**
	 * @property POST
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/POST:property&quot;}}{{/crossLink}} instead.
	 */
	s.POST = createjs.AbstractLoader.POST;

	/**
	 * @property GET
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink &quot;AbstractLoader/GET:property&quot;}}{{/crossLink}} instead.
	 */
	s.GET = createjs.AbstractLoader.GET;

// events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a &#x60;src&#x60; property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This {{#crossLink &quot;ProgressEvent&quot;}}{{/crossLink}} that is fired when an an individual file&#x27;s progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

	/**
	 * Although it extends {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}}, the &#x60;initialize&#x60; event is never fired from
	 * a LoadQueue instance.
	 * @event initialize
	 * @private
	 */

// public methods
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink &quot;AbstractLoader&quot;}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	p.registerLoader = function (loader) {
		if (!loader || !loader.canLoadItem) {
			throw new Error(&quot;loader is of an incorrect type.&quot;);
		} else if (this._availableLoaders.indexOf(loader) != -1) {
			throw new Error(&quot;loader already exists.&quot;); //LM: Maybe just silently fail here
		}

		this._availableLoaders.unshift(loader);
	};

	/**
	 * Remove a custom loader added using {{#crossLink &quot;registerLoader&quot;}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	p.unregisterLoader = function (loader) {
		var idx = this._availableLoaders.indexOf(loader);
		if (idx != -1 &amp;&amp; idx &lt; this._defaultLoaderLength - 1) {
			this._availableLoaders.splice(idx, 1);
		}
	};

	/**
	 * @method setUseXHR
	 * @param {Boolean} value The new useXHR value to set.
	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
	 * the provided value argument was true.
	 * @since 0.3.0
	 * @deprecated use the {{#crossLink &quot;LoadQueue/preferXHR:property&quot;}}{{/crossLink}} property, or the
	 * {{#crossLink &quot;LoadQueue/setUseXHR&quot;}}{{/crossLink}} method instead.
	 */
	p.setUseXHR = function (value) {
		return this.setPreferXHR(value);
	};

	/**
	 * Change the {{#crossLink &quot;preferXHR:property&quot;}}{{/crossLink}} value. Note that if this is set to &#x60;true&#x60;, it may
	 * fail, or be ignored depending on the browser&#x27;s capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink &quot;preferXHR&quot;}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	p.setPreferXHR = function (value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.preferXHR = (value != false &amp;&amp; window.XMLHttpRequest != null);
		return this.preferXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function () {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      queue.loadManifest([
	 *          {src:&quot;test.png&quot;, id:&quot;png&quot;},
	 *          {src:&quot;test.jpg&quot;, id:&quot;jpg&quot;},
	 *          {src:&quot;test.mp3&quot;, id:&quot;mp3&quot;}
	 *      ]);
	 *      queue.remove(&quot;png&quot;); // Single item by ID
	 *      queue.remove(&quot;png&quot;, &quot;test.jpg&quot;); // Items as arguments. Mixed id and src.
	 *      queue.remove([&quot;test.png&quot;, &quot;jpg&quot;]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function (idsOrUrls) {
		var args = null;

		if (idsOrUrls &amp;&amp; !Array.isArray(idsOrUrls)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length &gt; 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.preferXHR, this._basePath);

			// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length - 1; i &gt;= 0; i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i, 1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length - 1; i &gt;= 0; i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i, 1)[0].cancel();
						break;
					}
				}

				if (r) {
					this._disposeItem(this.getItem(item));
				} else {
					for (var i = this._currentLoads.length - 1; i &gt;= 0; i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i, 1)[0].cancel();
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink &quot;AbstractLoader/load&quot;}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink &quot;LoadQueue/remove&quot;}}{{/crossLink}} or
	 * {{#crossLink &quot;LoadQueue/removeAll&quot;}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function () {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i = 0, l = this._loadQueueBackup.length; i &lt; l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a &lt;code&gt;getPreloadHandlers()&lt;/code&gt; method will be called on it. For more information
	 * on this method, check out the {{#crossLink &quot;SamplePlugin/getPreloadHandlers&quot;}}{{/crossLink}} method in the
	 * {{#crossLink &quot;SamplePlugin&quot;}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a &#x60;callback&#x60; is returned
	 * from the {{#crossLink &quot;SamplePlugin/getPreloadHandlers&quot;}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a &#x60;completeHandler&#x60; to be fired when
	 * the file is loaded, or a &#x60;tag&#x60; object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink &quot;SamplePlugin/preloadHandler&quot;}}{{/crossLink}} and {{#crossLink &quot;SamplePlugin/fileLoadHandler&quot;}}{{/crossLink}}
	 * methods on the {{#crossLink &quot;SamplePlugin&quot;}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function (plugin) {
		if (plugin == null) {
			return;
		}

		if (plugin.getPreloadHandlers != null) {
			this._plugins.push(plugin);
			var map = plugin.getPreloadHandlers();
			map.scope = plugin;

			if (map.types != null) {
				for (var i = 0, l = map.types.length; i &lt; l; i++) {
					this._typeCallbacks[map.types[i]] = map;
				}
			}

			if (map.extensions != null) {
				for (i = 0, l = map.extensions.length; i &lt; l; i++) {
					this._extensionCallbacks[map.extensions[i]] = map;
				}
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink &quot;LoadQueue/maintainScriptOrder:property&quot;}}{{/crossLink}}
	 * is &#x60;true&#x60;, only one script is loaded at a time due to browser limitations.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused &amp;&amp; this._loadQueue.length &gt; 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink &quot;AbstractLoader/close&quot;}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * &lt;ul&gt;
	 *     &lt;li&gt;A {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}} instance&lt;/li&gt;
	 *     &lt;li&gt;An object containing properties defined by {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}
	 *     in the background.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink &quot;LoadQueue/setPaused&quot;}}{{/crossLink}}, and the value is
	 * &#x60;true&#x60;, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink &quot;AbstractLoader/MANIFEST:property&quot;}}{{/crossLink}},
	 * its files will &lt;strong&gt;NOT&lt;/strong&gt; use the basePath parameter. &lt;strong&gt;The basePath parameter is deprecated.&lt;/strong&gt;
	 * This parameter will be removed in a future version. Please either use the &#x60;basePath&#x60; parameter in the LoadQueue
	 * constructor, or a &#x60;path&#x60; property in a manifest definition.
	 */
	p.loadFile = function (file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.ErrorEvent(&quot;PRELOAD_NO_FILE&quot;);
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink &quot;LoadQueue/maintainScriptOrder&quot;}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink &quot;AbstractLoader/close&quot;}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * &lt;ol&gt;
	 *     &lt;li&gt;A string path, which points to a manifest file, which is a JSON file that contains a &quot;manifest&quot; property,
	 *     which defines the list of files to load, and can optionally contain a &quot;path&quot; property, which will be
	 *     prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An object which defines a &quot;src&quot;, which is a JSON or JSONP file. A &quot;callback&quot; can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a &quot;manifest&quot; property, which defines the list of files to load,
	 *     and can optionally contain a &quot;path&quot; property, which will be prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An object which contains a &quot;manifest&quot; property, which defines the list of files to load, and can
	 *     optionally contain a &quot;path&quot; property, which will be prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An Array of files to load.&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * Each &quot;file&quot; in a manifest can be either:
	 * &lt;ul&gt;
	 *     &lt;li&gt;A {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}} instance&lt;/li&gt;
	 *     &lt;li&gt;An object containing properties defined by {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}
	 *     in the background.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink &quot;LoadQueue/setPaused&quot;}}{{/crossLink}} and this value is
	 * &#x60;true&#x60;, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink &quot;LoadQueue/MANIFEST:property&quot;}}{{/crossLink}},
	 * its files will &lt;strong&gt;NOT&lt;/strong&gt; use the basePath parameter. &lt;strong&gt;The basePath parameter is deprecated.&lt;/strong&gt;
	 * This parameter will be removed in a future version. Please either use the &#x60;basePath&#x60; parameter in the LoadQueue
	 * constructor, or a &#x60;path&#x60; property in a manifest definition.
	 */
	p.loadManifest = function (manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (Array.isArray(manifest)) {
			if (manifest.length == 0) {
				var event = new createjs.ErrorEvent(&quot;PRELOAD_MANIFEST_EMPTY&quot;);
				this._sendError(event);
				return;
			}
			fileList = manifest;

			// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === &quot;string&quot;) {
			fileList = [
				{
					src: manifest,
					type: s.MANIFEST
				}
			];

		} else if (typeof(manifest) == &quot;object&quot;) {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.ErrorEvent(&quot;PRELOAD_MANIFEST_TYPE&quot;);
					this._sendError(event);
				}
				fileList = [manifest];

				// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

			// Unsupported. This will throw an error.
		} else {
			var event = new createjs.ErrorEvent(&quot;PRELOAD_MANIFEST_NULL&quot;);
			this._sendError(event);
			return;
		}

		for (var i = 0, l = fileList.length; i &lt; l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	p.load = function () {
		this.setPaused(false);
	};

	/**
	 * Look up a {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}} using either the &quot;id&quot; or &quot;src&quot; that was specified when loading it. Note that if no &quot;id&quot; was
	 * supplied with the load item, the ID will be the &quot;src&quot;, including a &#x60;path&#x60; property defined by a manifest. The
	 * &#x60;basePath&#x60; will not be part of the ID.
	 * @method getItem
	 * @param {String} value The &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}. This object is also returned via the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}}
	 * event as the &#x60;item&#x60; parameter.
	 */
	p.getItem = function (value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the &quot;id&quot; or &quot;src&quot; that was specified when loading it. Note that if no &quot;id&quot;
	 * was supplied with the load item, the ID will be the &quot;src&quot;, including a &#x60;path&#x60; property defined by a manifest. The
	 * &#x60;basePath&#x60; will not be part of the ID.
	 * @method getResult
	 * @param {String} value The &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * &lt;ul&gt;
	 *      &lt;li&gt;An image tag (&amp;lt;image /&amp;gt;) for images&lt;/li&gt;
	 *      &lt;li&gt;A script tag for JavaScript (&amp;lt;script /&amp;gt;). Note that scripts are automatically added to the HTML
	 *      DOM.&lt;/li&gt;
	 *      &lt;li&gt;A style tag for CSS (&amp;lt;style /&amp;gt; or &amp;lt;link &amp;gt;)&lt;/li&gt;
	 *      &lt;li&gt;Raw text for TEXT&lt;/li&gt;
	 *      &lt;li&gt;A formatted JavaScript object defined by JSON&lt;/li&gt;
	 *      &lt;li&gt;An XML document&lt;/li&gt;
	 *      &lt;li&gt;A binary arraybuffer loaded by XHR&lt;/li&gt;
	 *      &lt;li&gt;An audio tag (&amp;lt;audio &amp;gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * This object is also returned via the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}} event as the &#x27;item&#x60;
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) {
			return null;
		}
		var id = item.id;
		if (rawResult &amp;&amp; this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	p.getItems = function (loaded) {
		var arr = [];
		for (var n in this._loadItemsById) {
			var item = this._loadItemsById[n];
			var result = this.getResult(n);
			if (loaded === true &amp;&amp; result == null) {
				continue;
			}
			arr.push({
				item: item,
				result: result,
				rawResult: this.getResult(n, true)
			});
		}
		return arr;
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} or
	 * {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}, a paused queue will be resumed, unless the &#x60;loadNow&#x60;
	 * argument is &#x60;false&#x60;.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function (value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink &quot;LoadQueue/setPaused&quot;}}{{/crossLink}} method instead.
	 * @method close
	 */
	p.close = function () {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
		this._itemCount = 0;
		this._lastProgress = NaN;
	};

// protected methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink &quot;LoadQueue.getItem&quot;}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the &#x60;src&#x60;. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as &#x60;http://&#x60;, or a path like &#x60;../&#x60;. If the LoadQueue was
	 * provided a {{#crossLink &quot;_basePath&quot;}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] &lt;strong&gt;Deprecated&lt;/strong&gt;An optional basePath passed into a {{#crossLink &quot;LoadQueue/loadManifest&quot;}}{{/crossLink}}
	 * or {{#crossLink &quot;LoadQueue/loadFile&quot;}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function (value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) {
			return;
		} // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			if (&quot;plugins&quot; in loader) {
				loader.plugins = this._plugins;
			}
			item._loader = loader;
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if ((this.maintainScriptOrder
					&amp;&amp; item.type == createjs.LoadQueue.JAVASCRIPT
						//&amp;&amp; loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
					)
					|| item.maintainOrder === true) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item&#x27;s source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the &#x60;path&#x60; and {{#crossLink &quot;LoadQueue/_basePath:property&quot;}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] &lt;strong&gt;Deprectated&lt;/strong&gt; A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function (value, path, basePath) {
		var item = createjs.LoadItem.create(value);
		if (item == null) {
			return null;
		}

		var bp = &quot;&quot;; // Store the generated basePath
		var useBasePath = basePath || this._basePath;

		if (item.src instanceof Object) {
			if (!item.type) {
				return null;
			} // the the src is an object, type is required to pass off to plugin
			if (path) {
				bp = path;
				var pathMatch = createjs.RequestUtils.parseURI(path);
				// Also append basePath
				if (useBasePath != null &amp;&amp; !pathMatch.absolute &amp;&amp; !pathMatch.relative) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		} else {
			// Determine Extension, etc.
			var match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension) {
				item.ext = match.extension;
			}
			if (item.type == null) {
				item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
			}

			// Inject path &amp; basePath
			var autoId = item.src;
			if (!match.absolute &amp;&amp; !match.relative) {
				if (path) {
					bp = path;
					var pathMatch = createjs.RequestUtils.parseURI(path);
					autoId = path + autoId;
					// Also append basePath
					if (useBasePath != null &amp;&amp; !pathMatch.absolute &amp;&amp; !pathMatch.relative) {
						bp = useBasePath + bp;
					}
				} else if (useBasePath != null) {
					bp = useBasePath;
				}
			}
			item.src = bp + item.src;
		}
		item.path = bp;

		// If there&#x27;s no id, set one now.
		if (item.id === undefined || item.id === null || item.id === &quot;&quot;) {
			item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item, this);

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

				// Load as normal:
			} else if (result === true) {
				// Do Nothing

				// Result is a loader class:
			} else if (result != null) {
				item._loader = result;
			}

			// Update the extension in case the type changed:
			match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension != null) {
				item.ext = match.extension;
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		if (item.crossOrigin == null) {
			item.crossOrigin = this._crossOrigin;
		}

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function (item) {
		if (item._loader != null) { // A plugin already specified a loader
			return item._loader;
		}

		// Initially, try and use the provided/supported XHR mode:
		var preferXHR = this.preferXHR;

		for (var i = 0; i &lt; this._availableLoaders.length; i++) {
			var loader = this._availableLoaders[i];
			if (loader &amp;&amp; loader.canLoadItem(item)) {
				return new loader(item, preferXHR);
			}
		}

		// TODO: Log error (requires createjs.log)
		return null;
	};

	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will &quot;fill up&quot; any empty slots, up to the max connection specified using
	 * {{#crossLink &quot;LoadQueue.setMaxConnections&quot;}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function () {
		if (this._paused) {
			return;
		}

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next &amp;&amp; this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i = 0; i &lt; this._loadQueue.length; i++) {
			if (this._currentLoads.length &gt;= this._maxConnections) {
				break;
			}
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one tag-script at a time:
			// Note: maintainOrder items don&#x27;t do anything here because we can hold onto their loaded value
			if (!this._canStartLoad(loader)) {
				continue;
			}
			this._loadQueue.splice(i, 1);
			i--;
			this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function (loader) {
		loader.on(&quot;fileload&quot;, this._handleFileLoad, this);
		loader.on(&quot;progress&quot;, this._handleProgress, this);
		loader.on(&quot;complete&quot;, this._handleFileComplete, this);
		loader.on(&quot;error&quot;, this._handleError, this);
		loader.on(&quot;fileerror&quot;, this._handleFileError, this);
		this._currentLoads.push(loader);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink &quot;fileload:event&quot;}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink &quot;AbstractLoader/fileload:event&quot;}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	p._handleFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	p._handleFileError = function (event) {
		var newEvent = new createjs.ErrorEvent(&quot;FILE_LOAD_ERROR&quot;, null, event.item);
		this._sendError(newEvent);
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink &quot;LoadQueue/stopOnError:property&quot;}}{{/crossLink}}
	 * is set to &#x60;true&#x60;.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleError = function (event) {
		var loader = event.target;
		this._numItemsLoaded++;

		this._finishOrderedItem(loader, true);
		this._updateProgress();

		var newEvent = new createjs.ErrorEvent(&quot;FILE_LOAD_ERROR&quot;, null, loader.getItem());
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._cleanLoadItem(loader);
			this._loadNext();
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the &quot;result&quot; property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the &quot;rawResult&quot; property, and can also be looked up using {{#crossLink &quot;LoadQueue/getResult&quot;}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function (event) {
		var loader = event.target;
		var item = loader.getItem();

		var result = loader.getResult();
		this._loadedResults[item.id] = result;
		var rawResult = loader.getResult(true);
		if (rawResult != null &amp;&amp; rawResult !== result) {
			this._loadedRawResults[item.id] = rawResult;
		}

		this._saveLoadedItems(loader);

		// Remove the load item
		this._removeLoadItem(loader);

		if (!this._finishOrderedItem(loader)) {
			// The item was NOT managed, so process it now
			this._processFinishedLoad(item, loader);
		}

		// Clean up the load item
		this._cleanLoadItem(loader);
	};

	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink &quot;AbstractLoader/getLoadItems&quot;}}{{/crossLink}} are added to the
	 * LoadQueue&#x27;s look-ups, including {{#crossLink &quot;getItem&quot;}}{{/crossLink}} and {{#crossLink &quot;getResult&quot;}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	p._saveLoadedItems = function (loader) {
		// TODO: Not sure how to handle this. Would be nice to expose the items.
		// Loaders may load sub-items. This adds them to this queue
		var list = loader.getLoadedItems();
		if (list === null) {
			return;
		}

		for (var i = 0; i &lt; list.length; i++) {
			var item = list[i].item;

			// Store item lookups
			this._loadItemsBySrc[item.src] = item;
			this._loadItemsById[item.id] = item;

			// Store loaded content
			this._loadedResults[item.id] = list[i].result;
			this._loadedRawResults[item.id] = list[i].rawResult;
		}
	};

	/**
	 * Flag an item as finished. If the item&#x27;s order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item&#x27;s order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	p._finishOrderedItem = function (loader, loadFailed) {
		var item = loader.getItem();

		if ((this.maintainScriptOrder &amp;&amp; item.type == createjs.LoadQueue.JAVASCRIPT)
				|| item.maintainOrder) {

			//TODO: Evaluate removal of the _currentlyLoadingScript
			if (loader instanceof createjs.JavaScriptLoader) {
				this._currentlyLoadingScript = false;
			}

			var index = createjs.indexOf(this._scriptOrder, item);
			if (index == -1) {
				return false;
			} // This loader no longer exists
			this._loadedScripts[index] = (loadFailed === true) ? true : item;

			this._checkScriptLoadOrder();
			return true;
		}

		return false;
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a &quot;null&quot; value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to &#x60;true&#x60;. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a &#x60;null&#x60; value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i = 0; i &lt; l; i++) {
			var item = this._loadedScripts[i];
			if (item === null) {
				break;
			} // This is still loading. Do not process further.
			if (item === true) {
				continue;
			} // This has completed, and been processed. Move on.

			var loadItem = this._loadedResults[item.id];
			if (item.type == createjs.LoadQueue.JAVASCRIPT) {
				// Append script tags to the head automatically.
				createjs.DomUtils.appendToHead(loadItem);
			}

			var loader = item._loader;
			this._processFinishedLoad(item, loader);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function (item, loader) {
		this._numItemsLoaded++;

		// Since LoadQueue needs maintain order, we can&#x27;t append scripts in the loader.
		// So we do it here instead. Or in _checkScriptLoadOrder();
		if (!this.maintainScriptOrder &amp;&amp; item.type == createjs.LoadQueue.JAVASCRIPT) {
			var tag = loader.getTag();
			createjs.DomUtils.appendToHead(tag);
		}

		this._updateProgress();
		this._sendFileComplete(item, loader);
		this._loadNext();
	};

	/**
	 * Ensure items with &#x60;maintainOrder=true&#x60; that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed &lt;strong&gt;before&lt;/strong&gt;
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	p._canStartLoad = function (loader) {
		if (!this.maintainScriptOrder || loader.preferXHR) {
			return true;
		}
		var item = loader.getItem();
		if (item.type != createjs.LoadQueue.JAVASCRIPT) {
			return true;
		}
		if (this._currentlyLoadingScript) {
			return false;
		}

		var index = this._scriptOrder.indexOf(item);
		var i = 0;
		while (i &lt; index) {
			var checkItem = this._loadedScripts[i];
			if (checkItem == null) {
				return false;
			}
			i++;
		}
		this._currentlyLoadingScript = true;
		return true;
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function (loader) {
		var l = this._currentLoads.length;
		for (var i = 0; i &lt; l; i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i, 1);
				break;
			}
		}
	};

	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	p._cleanLoadItem = function(loader) {
		var item = loader.getItem();
		if (item) {
			delete item._loader;
		}
	}

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue&#x27;s overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function (event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don&#x27;t always know the actual filesize of items before
	 * they are loaded. In this case, we define a &quot;slot&quot; for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * &lt;ul&gt;
	 *      &lt;li&gt;5/10 of the items in the queue (50%)&lt;/li&gt;
	 *      &lt;li&gt;plus 20% of item 6&#x27;s slot (2%)&lt;/li&gt;
	 *      &lt;li&gt;equals 52%&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems - this._numItemsLoaded;
		if (remaining &gt; 0) {
			var chunk = 0;
			for (var i = 0, l = this._currentLoads.length; i &lt; l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining / this._numItems);
		}

		if (this._lastProgress != loaded) {
			this._sendProgress(loaded);
			this._lastProgress = loaded;
		}
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function (item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};

	/**
	 * Dispatch a &quot;fileprogress&quot; {{#crossLink &quot;Event&quot;}}{{/crossLink}}. Please see the LoadQueue {{#crossLink &quot;LoadQueue/fileprogress:event&quot;}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function (item, progress) {
		if (this._isCanceled() || this._paused) {
			return;
		}
		if (!this.hasEventListener(&quot;fileprogress&quot;)) {
			return;
		}

		//LM: Rework ProgressEvent to support this?
		var event = new createjs.Event(&quot;fileprogress&quot;);
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload {{#crossLink &quot;Event&quot;}}{{/crossLink}}. Please see the {{#crossLink &quot;LoadQueue/fileload:event&quot;}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function (item, loader) {
		if (this._isCanceled() || this._paused) {
			return;
		}

		var event = new createjs.Event(&quot;fileload&quot;);
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

		// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
		if (item.completeHandler) {
			item.completeHandler(event);
		}

		this.hasEventListener(&quot;fileload&quot;) &amp;&amp; this.dispatchEvent(event);
	};

	/**
	 * Dispatch a filestart {{#crossLink &quot;Event&quot;}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink &quot;LoadQueue/filestart:event&quot;}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function (item) {
		var event = new createjs.Event(&quot;filestart&quot;);
		event.item = item;
		this.hasEventListener(&quot;filestart&quot;) &amp;&amp; this.dispatchEvent(event);
	};

	p.toString = function () {
		return &quot;[PreloadJS LoadQueue]&quot;;
	};

	createjs.LoadQueue = createjs.promote(LoadQueue, &quot;AbstractLoader&quot;);
}());

//##############################################################################
// TextLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for Text files.
	 * @class TextLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function TextLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);
	};

	var p = createjs.extend(TextLoader, createjs.AbstractLoader);
	var s = TextLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink &quot;AbstractLoader/TEXT:property&quot;}}{{/crossLink}},
	 * but is also the default loader if a file type can not be determined.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.TEXT;
	};

	createjs.TextLoader = createjs.promote(TextLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// BinaryLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.
	 * @class BinaryLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function BinaryLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);
		this.on(&quot;initialize&quot;, this._updateXHR, this);
	};

	var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
	var s = BinaryLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/BINARY:property&quot;}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.BINARY;
	};

	// private methods
	/**
	 * Before the item loads, set the response type to &quot;arraybuffer&quot;
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.setResponseType(&quot;arraybuffer&quot;);
	};

	createjs.BinaryLoader = createjs.promote(BinaryLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// CSSLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for CSS files.
	 * @class CSSLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function CSSLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = &quot;href&quot;;

		if (preferXHR) {
			this._tag = document.createElement(&quot;style&quot;);
		} else {
			this._tag = document.createElement(&quot;link&quot;);
		}

		this._tag.rel = &quot;stylesheet&quot;;
		this._tag.type = &quot;text/css&quot;;
	};

	var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
	var s = CSSLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/CSS:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.CSS;
	};

	// protected methods
	/**
	 * The result formatter for CSS files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		if (this._preferXHR) {
			var tag = loader.getTag();

			if (tag.styleSheet) { // IE
				tag.styleSheet.cssText = loader.getResult(true);
			} else {
				var textNode = document.createTextNode(loader.getResult(true));
				tag.appendChild(textNode);
			}
		} else {
			tag = this._tag;
		}

		createjs.DomUtils.appendToHead(tag);

		return tag;
	};

	createjs.CSSLoader = createjs.promote(CSSLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// ImageLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for image files.
	 * @class ImageLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ImageLoader (loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = &quot;src&quot;;

		// Check if the preload item is already a tag.
		if (createjs.RequestUtils.isImageTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {
			this._tag = loadItem.src;
		} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {
			this._tag = loadItem.tag;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		} else {
			this._tag = document.createElement(&quot;img&quot;);
		}

		this.on(&quot;initialize&quot;, this._updateXHR, this);
	};

	var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
	var s = ImageLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/IMAGE:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.IMAGE;
	};

	// public methods
	p.load = function () {
		if (this._tag.src != &quot;&quot; &amp;&amp; this._tag.complete) {
			this._sendComplete();
			return;
		}

		var crossOrigin = this._item.crossOrigin;
		if (crossOrigin == true) { crossOrigin = &quot;Anonymous&quot;; }
		if (crossOrigin != null &amp;&amp; !createjs.RequestUtils.isLocal(this._item.src)) {
			this._tag.crossOrigin = crossOrigin;
		}

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Before the item loads, set its mimeType and responseType.
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.mimeType = &#x27;text/plain; charset=x-user-defined-binary&#x27;;

		// Only exists for XHR
		if (event.loader.setResponseType) {
			event.loader.setResponseType(&quot;blob&quot;);
		}
	};

	/**
	 * The result formatter for Image files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLImageElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		return this._formatImage;
	};

	/**
	 * The asynchronous image formatter function. This is required because images have
	 * a short delay before they are ready.
	 * @method _formatImage
	 * @param {Function} successCallback The method to call when the result has finished formatting
	 * @param {Function} errorCallback The method to call if an error occurs during formatting
	 * @private
	 */
	p._formatImage = function (successCallback, errorCallback) {
		var tag = this._tag;
		var URL = window.URL || window.webkitURL;

		if (!this._preferXHR) {
			//document.body.removeChild(tag);
		} else if (URL) {
			var objURL = URL.createObjectURL(this.getResult(true));
			tag.src = objURL;

			tag.addEventListener(&quot;load&quot;, this._cleanUpURL, false);
			tag.addEventListener(&quot;error&quot;, this._cleanUpURL, false);
		} else {
			tag.src = this._item.src;
		}

		if (tag.complete) {
			successCallback(tag);
		} else {
            tag.onload = createjs.proxy(function() {
                successCallback(this._tag);
            }, this);

            tag.onerror = createjs.proxy(function() {
                errorCallback(_this._tag);
            }, this);
		}
	};

	/**
	 * Clean up the ObjectURL, the tag is done with it. Note that this function is run
	 * as an event listener without a proxy/closure, as it doesn&#x27;t require it - so do not
	 * include any functionality that requires scope without changing it.
	 * @method _cleanUpURL
	 * @param event
	 * @private
	 */
	p._cleanUpURL = function (event) {
		var URL = window.URL || window.webkitURL;
		URL.revokeObjectURL(event.target.src);
	};

	createjs.ImageLoader = createjs.promote(ImageLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// JavaScriptLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for JavaScript files.
	 * @class JavaScriptLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JavaScriptLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = &quot;src&quot;;
		this.setTag(document.createElement(&quot;script&quot;));
	};

	var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
	var s = JavaScriptLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/JAVASCRIPT:property&quot;}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JAVASCRIPT;
	};

	// protected methods
	/**
	 * The result formatter for JavaScript files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var tag = loader.getTag();
		if (this._preferXHR) {
			tag.text = loader.getResult(true);
		}
		return tag;
	};

	createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// JSONLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink &quot;JSONPLoader&quot;}}{{/crossLink}}
	 * instead. To load JSON-formatted manifests, use {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}, and to
	 * load EaselJS SpriteSheets, use {{#crossLink &quot;SpriteSheetLoader&quot;}}{{/crossLink}}.
	 * @class JSONLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
	var s = JSONLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/JSON:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSON;
	};

	// protected methods
	/**
	 * The result formatter for JSON files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var json = null;
		try {
			json = createjs.DataUtils.parseJSON(loader.getResult(true));
		} catch (e) {
			var event = new createjs.ErrorEvent(&quot;JSON_FORMAT&quot;, null, e);
			this._sendError(event);
			return e;
		}

		return json;
	};

	createjs.JSONLoader = createjs.promote(JSONLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// JSONPLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON
	 * without a callback use the {{#crossLink &quot;JSONLoader&quot;}}{{/crossLink}} instead. To load JSON-formatted manifests,
	 * use {{#crossLink &quot;ManifestLoader&quot;}}{{/crossLink}}, and to load EaselJS SpriteSheets, use
	 * {{#crossLink &quot;SpriteSheetLoader&quot;}}{{/crossLink}}.
	 *
	 * JSONP is a format that provides a solution for loading JSON files cross-domain &lt;em&gt;without&lt;/em&gt; requiring CORS.
	 * JSONP files are loaded as JavaScript, and the &quot;callback&quot; is executed once they are loaded. The callback in the
	 * JSONP must match the callback passed to the loadItem.
	 *
	 * &lt;h4&gt;Example JSONP&lt;/h4&gt;
	 *
	 * 		callbackName({
	 * 			&quot;name&quot;: &quot;value&quot;,
	 *	 		&quot;num&quot;: 3,
	 *			&quot;obj&quot;: { &quot;bool&quot;:true }
	 * 		});
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 * 		var loadItem = {id:&quot;json&quot;, type:&quot;jsonp&quot;, src:&quot;http://server.com/text.json&quot;, callback:&quot;callbackName&quot;}
	 * 		var queue = new createjs.LoadQueue();
	 * 		queue.on(&quot;complete&quot;, handleComplete);
	 * 		queue.loadItem(loadItem);
	 *
	 * 		function handleComplete(event) }
	 * 			var json = queue.getResult(&quot;json&quot;);
	 * 			console.log(json.obj.bool); // true
	 * 		}
	 *
	 * Note that JSONP files loaded concurrently require a &lt;em&gt;unique&lt;/em&gt; callback. To ensure JSONP files are loaded
	 * in order, either use the {{#crossLink &quot;LoadQueue/setMaxConnections&quot;}}{{/crossLink}} method (set to 1),
	 * or set {{#crossLink &quot;LoadItem/maintainOrder:property&quot;}}{{/crossLink}} on items with the same callback.
	 *
	 * @class JSONPLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONPLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);
		this.setTag(document.createElement(&quot;script&quot;));
		this.getTag().type = &quot;text/javascript&quot;;
	};

	var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
	var s = JSONPLoader;


	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/JSONP:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSONP;
	};

	// public methods
	p.cancel = function () {
		this.AbstractLoader_cancel();
		this._dispose();
	};

	/**
	 * Loads the JSONp file.  Because of the unique loading needs of JSONp
	 * we don&#x27;t use the AbstractLoader.load() method.
	 *
	 * @method load
	 *
	 */
	p.load = function () {
		if (this._item.callback == null) {
			throw new Error(&#x27;callback is required for loading JSONP requests.&#x27;);
		}

		// TODO: Look into creating our own iFrame to handle the load
		// In the first attempt, FF did not get the result
		//   result instanceof Object did not work either
		//   so we would need to clone the result.
		if (window[this._item.callback] != null) {
			throw new Error(
				&quot;JSONP callback &#x27;&quot; +
				this._item.callback +
				&quot;&#x27; already exists on window. You need to specify a different callback or re-name the current one.&quot;);
		}

		window[this._item.callback] = createjs.proxy(this._handleLoad, this);
		window.document.body.appendChild(this._tag);

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		// Load the tag
		this._tag.src = this._item.src;
	};

	// private methods
	/**
	 * Handle the JSONP callback, which is a public method defined on &#x60;window&#x60;.
	 * @method _handleLoad
	 * @param {Object} data The formatted JSON data.
	 * @private
	 */
	p._handleLoad = function (data) {
		this._result = this._rawResult = data;
		this._sendComplete();

		this._dispose();
	};

	/**
	 * The tag request has not loaded within the time specfied in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._dispose();
		this.dispatchEvent(new createjs.ErrorEvent(&quot;timeout&quot;));
	};

	/**
	 * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.
	 * @method _dispose
	 * @private
	 */
	p._dispose = function () {
		window.document.body.removeChild(this._tag);
		delete window[this._item.callback];

		clearTimeout(this._loadTimeout);
	};

	createjs.JSONPLoader = createjs.promote(JSONPLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// ManifestLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests
	 * using JSONP, specify a {{#crossLink &quot;LoadItem/callback:property&quot;}}{{/crossLink}} as part of the
	 * {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}.
	 *
	 * The list of files in the manifest must be defined on the top-level JSON object in a &#x60;manifest&#x60; property. This
	 * example shows a sample manifest definition, as well as how to to include a sub-manifest.
	 *
	 * 		{
	 * 			&quot;path&quot;: &quot;assets/&quot;,
	 *	 	    &quot;manifest&quot;: [
	 *				&quot;image.png&quot;,
	 *				{&quot;src&quot;: &quot;image2.png&quot;, &quot;id&quot;:&quot;image2&quot;},
	 *				{&quot;src&quot;: &quot;sub-manifest.json&quot;, &quot;type&quot;:&quot;manifest&quot;, &quot;callback&quot;:&quot;jsonCallback&quot;}
	 *	 	    ]
	 *	 	}
	 *
	 * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}},
	 * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.
	 *
	 * Note that the {{#crossLink &quot;JSONLoader&quot;}}{{/crossLink}} and {{#crossLink &quot;JSONPLoader&quot;}}{{/crossLink}} are
	 * higher priority loaders, so manifests &lt;strong&gt;must&lt;/strong&gt; set the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}
	 * {{#crossLink &quot;LoadItem/type:property&quot;}}{{/crossLink}} property to {{#crossLink &quot;AbstractLoader/MANIFEST:property&quot;}}{{/crossLink}}.
	 * @class ManifestLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ManifestLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);

	// Public Properties
		/**
		 * An array of the plugins registered using {{#crossLink &quot;LoadQueue/installPlugin&quot;}}{{/crossLink}},
		 * used to pass plugins to new LoadQueues that may be created.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this.plugins = null;


	// Protected Properties
		/**
		 * An internal {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} that loads the contents of the manifest.
		 * @property _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	};

	var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
	var s = ManifestLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property MANIFEST_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.MANIFEST_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/MANIFEST:property&quot;}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.MANIFEST;
	};

	// public methods
	p.load = function () {
		this.AbstractLoader_load();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case &quot;complete&quot;:
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.MANIFEST_PROGRESS);
				this._loadManifest(this._result);
				return;
			case &quot;progress&quot;:
				event.loaded *= s.MANIFEST_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	p.destroy = function() {
		this.AbstractLoader_destroy();
		this._manifestQueue.close();
	};

	/**
	 * Create and load the manifest items once the actual manifest has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json &amp;&amp; json.manifest) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on(&quot;fileload&quot;, this._handleManifestFileLoad, this);
			queue.on(&quot;progress&quot;, this._handleManifestProgress, this);
			queue.on(&quot;complete&quot;, this._handleManifestComplete, this, true);
			queue.on(&quot;error&quot;, this._handleManifestError, this, true);
			for(var i = 0, l = this.plugins.length; i &lt; l; i++) {	// conserve order of plugins
				queue.installPlugin(this.plugins[i]);
			}
			queue.loadManifest(json);
		} else {
			this._sendComplete();
		}
	};

	/**
	 * An item from the {{#crossLink &quot;_manifestQueue:property&quot;}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The manifest has completed loading. This triggers the {{#crossLink &quot;AbstractLoader/complete:event&quot;}}{{/crossLink}}
	 * {{#crossLink &quot;Event&quot;}}{{/crossLink}} from the ManifestLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The manifest has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * The manifest has reported an error with one of the files.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event(&quot;fileerror&quot;);
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.ManifestLoader = createjs.promote(ManifestLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
	 * should be created by either a library playing the sound (such as &lt;a href=&quot;http://soundjs.com&quot;&gt;SoundJS&lt;/a&gt;, or an
	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the
	 * {{#crossLink &quot;BinaryLoader&quot;}}{{/crossLink}}, and handle the audio context decoding manually.
	 * @class SoundLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function SoundLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);

		// protected properties
		if (createjs.RequestUtils.isAudioTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		}
	};

	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
	var s = SoundLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/SOUND:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SOUND;
	};

	// protected methods
	p._createTag = function (src) {
		var tag = document.createElement(&quot;audio&quot;);
		tag.autoplay = false;
		tag.preload = &quot;none&quot;;

		//LM: Firefox fails when this the preload=&quot;none&quot; for other tags, but it needs to be &quot;none&quot; to ensure PreloadJS works.
		tag.src = src;
		return tag;
	};

	createjs.SoundLoader = createjs.promote(SoundLoader, &quot;AbstractMediaLoader&quot;);

}());

//##############################################################################
// VideoLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for video files.
	 * @class VideoLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function VideoLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);

		if (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {
			this.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);

			// We can&#x27;t use XHR for a tag that&#x27;s passed in.
			this._preferXHR = false;
		} else {
			this.setTag(this._createTag());
		}
	};

	var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
	var s = VideoLoader;

	/**
	 * Create a new video tag
	 *
	 * @returns {HTMLElement}
	 * @private
	 */
	p._createTag = function () {
		return document.createElement(&quot;video&quot;);
	};

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/VIDEO:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.VIDEO;
	};

	createjs.VideoLoader = createjs.promote(VideoLoader, &quot;AbstractMediaLoader&quot;);

}());

//##############################################################################
// SpriteSheetLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader
	 * completes. To load SpriteSheets using JSONP, specify a {{#crossLink &quot;LoadItem/callback:property&quot;}}{{/crossLink}}
	 * as part of the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}}. Note that the {{#crossLink &quot;JSONLoader&quot;}}{{/crossLink}}
	 * and {{#crossLink &quot;JSONPLoader&quot;}}{{/crossLink}} are higher priority loaders, so SpriteSheets &lt;strong&gt;must&lt;/strong&gt;
	 * set the {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}} {{#crossLink &quot;LoadItem/type:property&quot;}}{{/crossLink}} property
	 * to {{#crossLink &quot;AbstractLoader/SPRITESHEET:property&quot;}}{{/crossLink}}.
	 *
	 * The {{#crossLink &quot;LoadItem&quot;}}{{/crossLink}} {{#crossLink &quot;LoadItem/crossOrigin:property&quot;}}{{/crossLink}} as well
	 * as the {{#crossLink &quot;LoadQueue&#x27;s&quot;}}{{/crossLink}} &#x60;basePath&#x60; argument and {{#crossLink &quot;LoadQueue/_preferXHR&quot;}}{{/crossLink}}
	 * property supplied to the {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} are passed on to the sub-manifest that loads
	 * the SpriteSheet images.
	 *
	 * Note that the SpriteSheet JSON does not respect the {{#crossLink &quot;LoadQueue/_preferXHR:property&quot;}}{{/crossLink}}
	 * property, which should instead be determined by the presence of a {{#crossLink &quot;LoadItem/callback:property&quot;}}{{/crossLink}}
	 * property on the SpriteSheet load item. This is because the JSON loaded will have a different format depending on
	 * if it is loaded as JSON, so just changing &#x60;preferXHR&#x60; is not enough to change how it is loaded.
	 * @class SpriteSheetLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SpriteSheetLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SPRITESHEET);

		// protected properties
		/**
		 * An internal queue which loads the SpriteSheet&#x27;s images.
		 * @method _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	}

	var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
	var s = SpriteSheetLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property SPRITESHEET_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.SPRITESHEET_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/SPRITESHEET:property&quot;}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SPRITESHEET;
	};

	// public methods
	p.destroy = function() {
		this.AbstractLoader_destroy;
		this._manifestQueue.close();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case &quot;complete&quot;:
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.SPRITESHEET_PROGRESS);
				this._loadManifest(this._result);
				return;
			case &quot;progress&quot;:
				event.loaded *= s.SPRITESHEET_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	/**
	 * Create and load the images once the SpriteSheet JSON has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json &amp;&amp; json.images) {
			var queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);
			queue.on(&quot;complete&quot;, this._handleManifestComplete, this, true);
			queue.on(&quot;fileload&quot;, this._handleManifestFileLoad, this);
			queue.on(&quot;progress&quot;, this._handleManifestProgress, this);
			queue.on(&quot;error&quot;, this._handleManifestError, this, true);
			queue.loadManifest(json.images);
		}
	};

	/**
	 * An item from the {{#crossLink &quot;_manifestQueue:property&quot;}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		var image = event.result;
		if (image != null) {
			var images = this.getResult().images;
			var pos = images.indexOf(event.item.src);
			images[pos] = image;
		}
	};

	/**
	 * The images have completed loading. This triggers the {{#crossLink &quot;AbstractLoader/complete:event&quot;}}{{/crossLink}}
	 * {{#crossLink &quot;Event&quot;}}{{/crossLink}} from the SpriteSheetLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._result = new createjs.SpriteSheet(this._result);
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The images {{#crossLink &quot;LoadQueue&quot;}}{{/crossLink}} has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * An image has reported an error.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event(&quot;fileerror&quot;);
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// SVGLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for SVG files.
	 * @class SVGLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SVGLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = &quot;data&quot;;

		if (preferXHR) {
			this.setTag(document.createElement(&quot;svg&quot;));
		} else {
			this.setTag(document.createElement(&quot;object&quot;));
			this.getTag().type = &quot;image/svg+xml&quot;;
		}
	};

	var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
	var s = SVGLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/SVG:property&quot;}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SVG;
	};

	// protected methods
	/**
	 * The result formatter for SVG files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {Object}
	 * @private
	 */
	p._formatResult = function (loader) {
		// mime should be image/svg+xml, but Opera requires text/xml
		var xml = createjs.DataUtils.parseXML(loader.getResult(true), &quot;text/xml&quot;);
		var tag = loader.getTag();

		if (!this._preferXHR &amp;&amp; document.body.contains(tag)) {
			document.body.removeChild(tag);
		}

		if (xml.documentElement != null) {
			tag.appendChild(xml.documentElement);
			tag.style.visibility = &quot;visible&quot;;
			return tag;
		} else { // For browsers that don&#x27;t support SVG, just give them the XML. (IE 9-8)
			return xml;
		}
	};

	createjs.SVGLoader = createjs.promote(SVGLoader, &quot;AbstractLoader&quot;);

}());

//##############################################################################
// XMLLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	&quot;use strict&quot;;

	// constructor
	/**
	 * A loader for CSS files.
	 * @class XMLLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function XMLLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
	var s = XMLLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink &quot;AbstractLoader/XML:property&quot;}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.XML;
	};

	// protected methods
	/**
	 * The result formatter for XML files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {XMLDocument}
	 * @private
	 */
	p._formatResult = function (loader) {
		return createjs.DataUtils.parseXML(loader.getResult(true), &quot;text/xml&quot;);
	};

	createjs.XMLLoader = createjs.promote(XMLLoader, &quot;AbstractLoader&quot;);

}());
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
